/**
 * videojs-hlsjs-plugin
 * v1.0.15
 * 2020-06-29
 * www.streamroot.io
 * Copyright Êºè 2018
 **/
window.hlsSourceHandler = function (r) { var i = {}; function a(e) { if (i[e]) return i[e].exports; var t = i[e] = { i: e, l: !1, exports: {} }; return r[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports } return a.m = r, a.c = i, a.d = function (e, t, r) { a.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }, a.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, a.t = function (t, e) { if (1 & e && (t = a(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var r = Object.create(null); if (a.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) a.d(r, i, function (e) { return t[e] }.bind(null, i)); return r }, a.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return a.d(t, "a", t), t }, a.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, a.p = "", a(a.s = 0) }([function (e, t, r) { "use strict"; var i = r(1); window.videojs && (i.registerConfigPlugin(window.videojs), i.registerSourceHandler(window.videojs)), e.exports = { register: i.registerSourceHandler } }, function (e, t, r) { "use strict"; var C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, I = r(2); function i(e) { var t = this; e && (t.srOptions_ || (t.srOptions_ = {}), t.srOptions_.hlsjsConfig || (t.srOptions_.hlsjsConfig = e.hlsjsConfig), t.srOptions_.captionConfig || (t.srOptions_.captionConfig = e.captionConfig)) } e.exports = { registerSourceHandler: function (D) { var e, O = {}; function r(r, n) { n.name_ = "StreamrootHlsjs"; var s, o = n.el(), i = {}, a = null, l = null, u = null, d = null, c = null, f = null, g = D(n.options_.playerId), h = g.qualityLevels && g.qualityLevels(); h && g.hlsQualitySelector && (n.hls = {}); var p = !1; function v(e) { 1 === i[I.ErrorTypes.MEDIA_ERROR] ? s.recoverMediaError() : 2 === i[I.ErrorTypes.MEDIA_ERROR] ? (s.swapAudioCodec(), s.recoverMediaError()) : 2 < i[I.ErrorTypes.MEDIA_ERROR] && (n.error = function () { return e }, n.trigger("error")) } function m(e) { s.nextLevel = e } function y(e, t) { return !!h && ("boolean" == typeof t && (h[e]._enabled = t, function () { for (var e = !0, t = 0; t < h.length; t++)if (!h[t]._enabled) { e = !1; break } if (e) s.currentLevel = -1; else { for (var r = h.length - 1; 0 <= r && !h[r]._enabled; r--); s.currentLevel = r } }()), h[e]._enabled) } function E(e, t) { h && (h.selectedIndex_ = t.level, h.trigger({ selectedIndex: t.level, type: "change" })) } function T() { var a, e, t; l && (a = [], 1 < l.levels.length && (e = { id: -1, label: "auto", selected: -1 === s.manualLevel }, a.push(e)), l.levels.forEach(function (e, t) { var r, i = {}; i.id = t, i.selected = t === s.manualLevel, i.label = (r = e).height ? r.height + "p" : r.width ? Math.round(9 * r.width / 16) + "p" : r.bitrate ? r.bitrate / 1e3 + "kbps" : 0, a.push(i) }), t = { qualityData: { video: a }, qualitySwitchCallback: m }, n.trigger("loadedqualitydata", t), o.removeEventListener("playing", T)) } function b() { for (var e = n.audioTracks(), t = 0; t < e.length; t++)if (e[t].enabled) { s.audioTrack = t; break } } function S() { var e = s.audioTracks, t = n.audioTracks(); if (1 < e.length && 0 === t.length) { for (var r = 0; r < e.length; r++)t.addTrack(new D.AudioTrack({ id: r, kind: "alternative", label: e[r].name || e[r].lang, language: e[r].lang, enabled: r === s.audioTrack })); t.addEventListener("change", b) } } function _(e) { return e.label ? e.label : e.language } function R(e, t) { return _(e) === _(t) && e.kind === t.kind } function A() { for (var e = g.textTracks(), t = null, r = 0; r < e.length; r++)if ("showing" === e[r].mode) { t = e[r]; break } for (var i = o.textTracks, a = 0; a < i.length; a++)"subtitles" !== i[a].kind && "captions" !== i[a].kind || (i[a].mode = t && R(i[a], t) ? "showing" : "disabled") } function k() { s.startLoad(-1), o.removeEventListener("play", k) } function w() { for (var e = function (e) { for (var t = [], r = 0; r < e.length; r++)"subtitles" !== e[r].kind && "captions" !== e[r].kind || t.push(e[r]); return t }(o.textTracks), t = g.textTracks(), r = 0; r < e.length; r++) { for (var i, a = !1, n = 0; n < t.length; n++)if (R(e[r], t[n])) { a = !0; break } a || (i = e[r], g.addRemoteTextTrack({ kind: i.kind, label: _(i), language: i.language, srclang: i.language }, !1)) } A(), p || (t.addEventListener("change", A), p = !0) } function L(e, t) { l = t, function () { if (l && (h = g.qualityLevels && g.qualityLevels())) { n.hls = {}; for (var e = 0; e < l.levels.length; e++) { var t = l.levels[e], r = "hlsjs-" + e, i = { id: r, label: r, width: t.width, height: t.height, bandwidth: t.bitrate, bitrate: t.bitrate, _enabled: !1 }; i.enabled = y.bind(this, e), h.addQualityLevel(i) } } }() } function e() { var e = g.srOptions_ && g.srOptions_.hlsjsConfig || n.options_.hlsjsConfig; f = e ? function (e) { for (var t = {}, r = Object.keys(e), i = 0; i < r.length; i++)t[r[i]] = e[r[i]]; return t }(e) : {}, -1 !== ["", "auto"].indexOf(o.preload) || o.autoplay || void 0 !== f.autoStartLoad || (f.autoStartLoad = !1); var h, t = g.srOptions_ && g.srOptions_.captionConfig || n.options_.captionConfig; t && (f.cueHandler = (h = t, { newCue: function (e, t, r, i) { for (var a, n, s, o = window.VTTCue || window.TextTrackCue, l = 0; l < i.rows.length; l++)if (s = "", !(a = i.rows[l]).isEmpty()) { for (var u = 0; u < a.chars.length; u++)s += a.chars[u].uchar; if (n = new o(t, r, s.trim()), null != h && "object" === (void 0 === h ? "undefined" : C(h))) for (var d = Object.keys(h), c = 0; c < d.length; c++)n[d[c]] = h[d[c]]; e.addCue(n), r === t && e.addCue(new o(r + 5, "")) } } })), !1 === f.autoStartLoad && o.addEventListener("play", k), o.addEventListener("playing", T), s = new I(f), function (e) { if (void 0 !== O[e]) for (var t = 0; t < O[e].length; t++)O[e][t](g, s) }("beforeinitialize"), s.on(I.Events.ERROR, function (e, t) { !function (e) { var t = { message: "HLS.js error: " + e.type + " - fatal: " + e.fatal + " - " + e.details }; if (i[e.type] ? i[e.type] += 1 : i[e.type] = 1, e.fatal) switch (e.type) { case I.ErrorTypes.NETWORK_ERROR: t.code = 2, n.error = function () { return t }, n.trigger("error"); break; case I.ErrorTypes.MEDIA_ERROR: t.code = 3, v(t); break; default: s.destroy(), n.error = function () { return t }, n.trigger("error") } }(t) }), s.on(I.Events.AUDIO_TRACKS_UPDATED, S), s.on(I.Events.MANIFEST_PARSED, L), s.on(I.Events.LEVEL_LOADED, function (e, t) { f.liveSyncDuration ? c = f.liveSyncDuration : f.liveSyncDurationCount && (c = f.liveSyncDurationCount * t.details.targetduration), u = t.details.live, d = t.details.totalduration, a = u ? 1 / 0 : t.details.totalduration }), s.once(I.Events.FRAG_LOADED, function () { n.trigger("loadedmetadata") }), s.on(I.Events.LEVEL_SWITCHED, E), s.attachMedia(o), o.textTracks.addEventListener("addtrack", w), s.loadSource(r.src) } this.duration = function () { return a || o.duration || 0 }, this.seekable = function () { if (s.media) { if (!u) return D.createTimeRanges(0, s.media.duration); var e = Math.round(s.media.duration - d), t = Math.round(s.media.duration - c); return D.createTimeRanges(e, t) } return D.createTimeRanges() }, this.dispose = function () { o.removeEventListener("play", k), o.textTracks.removeEventListener("addtrack", w), o.removeEventListener("playing", T), g.textTracks().removeEventListener("change", A), p = !1, g.audioTracks().removeEventListener("change", b), s.destroy() }, o.addEventListener("error", function (e) { var t = e.currentTarget.error; switch (t.code) { case t.MEDIA_ERR_ABORTED: 0; break; case t.MEDIA_ERR_DECODE: v(t); break; case t.MEDIA_ERR_NETWORK: 0; break; case t.MEDIA_ERR_SRC_NOT_SUPPORTED: 0; break; default: t.message } }), e() } if (r.addHook = function (e, t) { O[e] = O[e] || [], O[e].push(t) }, r.removeHook = function (e, t) { if (void 0 === O[e]) return !1; var r = O[e].indexOf(t); return -1 !== r && (O[e].splice(r, 1), !0) }, I.isSupported()) { if ("function" == typeof D.getTech) e = D.getTech("Html5"); else { if ("function" != typeof D.getComponent) return; e = D.getComponent("Html5") } if (!e) return; e.registerSourceHandler({ canHandleSource: function (e) { var t = /^application\/x-mpegURL|application\/vnd\.apple\.mpegurl$/i.test(e.type) ? "probably" : /\.m3u8/i.test(e.src) ? "maybe" : ""; return t }, handleSource: function (e, t) { return t.hlsProvider && t.hlsProvider.dispose(), t.hlsProvider = new r(e, t), t.hlsProvider } }, 0), D.Html5Hlsjs = r } }, registerConfigPlugin: function (e) { (e.registerPlugin || e.plugin)("streamrootHls", i) } } }, function (e, t, r) { var i; "undefined" != typeof window && (i = function () { return i = {}, a.m = r = { "./node_modules/eventemitter3/index.js": function (e, t, r) { "use strict"; var i = Object.prototype.hasOwnProperty, f = "~"; function a() { } function o(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function n(e, t, r, i, a) { if ("function" != typeof r) throw new TypeError("The listener must be a function"); var n = new o(r, i || e, a), s = f ? f + t : t; return e._events[s] ? e._events[s].fn ? e._events[s] = [e._events[s], n] : e._events[s].push(n) : (e._events[s] = n, e._eventsCount++), e } function u(e, t) { 0 == --e._eventsCount ? e._events = new a : delete e._events[t] } function s() { this._events = new a, this._eventsCount = 0 } Object.create && (a.prototype = Object.create(null), (new a).__proto__ || (f = !1)), s.prototype.eventNames = function () { var e, t, r = []; if (0 === this._eventsCount) return r; for (t in e = this._events) i.call(e, t) && r.push(f ? t.slice(1) : t); return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r }, s.prototype.listeners = function (e) { var t = f ? f + e : e, r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var i = 0, a = r.length, n = new Array(a); i < a; i++)n[i] = r[i].fn; return n }, s.prototype.listenerCount = function (e) { var t = f ? f + e : e, r = this._events[t]; return r ? r.fn ? 1 : r.length : 0 }, s.prototype.emit = function (e, t, r, i, a, n) { var s = f ? f + e : e; if (!this._events[s]) return !1; var o, l = this._events[s], u = arguments.length; if (l.fn) { switch (l.once && this.removeListener(e, l.fn, void 0, !0), u) { case 1: return l.fn.call(l.context), !0; case 2: return l.fn.call(l.context, t), !0; case 3: return l.fn.call(l.context, t, r), !0; case 4: return l.fn.call(l.context, t, r, i), !0; case 5: return l.fn.call(l.context, t, r, i, a), !0; case 6: return l.fn.call(l.context, t, r, i, a, n), !0 }for (h = 1, o = new Array(u - 1); h < u; h++)o[h - 1] = arguments[h]; l.fn.apply(l.context, o) } else for (var d, c = l.length, h = 0; h < c; h++)switch (l[h].once && this.removeListener(e, l[h].fn, void 0, !0), u) { case 1: l[h].fn.call(l[h].context); break; case 2: l[h].fn.call(l[h].context, t); break; case 3: l[h].fn.call(l[h].context, t, r); break; case 4: l[h].fn.call(l[h].context, t, r, i); break; default: if (!o) for (d = 1, o = new Array(u - 1); d < u; d++)o[d - 1] = arguments[d]; l[h].fn.apply(l[h].context, o) }return !0 }, s.prototype.on = function (e, t, r) { return n(this, e, t, r, !1) }, s.prototype.once = function (e, t, r) { return n(this, e, t, r, !0) }, s.prototype.removeListener = function (e, t, r, i) { var a = f ? f + e : e; if (!this._events[a]) return this; if (!t) return u(this, a), this; var n = this._events[a]; if (n.fn) n.fn !== t || i && !n.once || r && n.context !== r || u(this, a); else { for (var s = 0, o = [], l = n.length; s < l; s++)(n[s].fn !== t || i && !n[s].once || r && n[s].context !== r) && o.push(n[s]); o.length ? this._events[a] = 1 === o.length ? o[0] : o : u(this, a) } return this }, s.prototype.removeAllListeners = function (e) { var t; return e ? (t = f ? f + e : e, this._events[t] && u(this, t)) : (this._events = new a, this._eventsCount = 0), this }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = f, s.EventEmitter = s, e.exports = s }, "./node_modules/url-toolkit/src/url-toolkit.js": function (e, t, r) { var i, d, a, n, c; i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, d = /^([^\/?#]*)(.*)$/, a = /(?:\/|^)\.(?=\/)/g, n = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, c = { buildAbsoluteURL: function (e, t, r) { if (r = r || {}, e = e.trim(), !(t = t.trim())) { if (!r.alwaysNormalize) return e; var i = c.parseURL(e); if (!i) throw new Error("Error trying to parse base URL."); return i.path = c.normalizePath(i.path), c.buildURLFromParts(i) } var a = c.parseURL(t); if (!a) throw new Error("Error trying to parse relative URL."); if (a.scheme) return r.alwaysNormalize ? (a.path = c.normalizePath(a.path), c.buildURLFromParts(a)) : t; var n, s = c.parseURL(e); if (!s) throw new Error("Error trying to parse base URL."); !s.netLoc && s.path && "/" !== s.path[0] && (n = d.exec(s.path), s.netLoc = n[1], s.path = n[2]), s.netLoc && !s.path && (s.path = "/"); var o, l, u = { scheme: s.scheme, netLoc: a.netLoc, path: null, params: a.params, query: a.query, fragment: a.fragment }; return a.netLoc || (u.netLoc = s.netLoc, "/" !== a.path[0] && (a.path ? (l = (o = s.path).substring(0, o.lastIndexOf("/") + 1) + a.path, u.path = c.normalizePath(l)) : (u.path = s.path, a.params || (u.params = s.params, a.query || (u.query = s.query))))), null === u.path && (u.path = r.alwaysNormalize ? c.normalizePath(a.path) : a.path), c.buildURLFromParts(u) }, parseURL: function (e) { var t = i.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(a, ""); e.length !== (e = e.replace(n, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, e.exports = c }, "./node_modules/webworkify-webpack/index.js": function (e, t, f) { function l(r) { var i = {}; function a(e) { if (i[e]) return i[e].exports; var t = i[e] = { i: e, l: !1, exports: {} }; return r[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports } a.m = r, a.c = i, a.i = function (e) { return e }, a.d = function (e, t, r) { a.o(e, t) || Object.defineProperty(e, t, { configurable: !1, enumerable: !0, get: r }) }, a.r = function (e) { Object.defineProperty(e, "__esModule", { value: !0 }) }, a.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return a.d(t, "a", t), t }, a.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, a.p = "/", a.oe = function (e) { throw e }; var e = a(a.s = ENTRY_MODULE); return e.default || e } var g = "[\\.|\\-|\\+|\\w|/|@]+", p = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + g + ").*?\\)"; function v(e) { return (e + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&") } function h(e, t, r) { var i = {}; i[r] = []; var a = t.toString(), n = a.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/); if (!n) return i; for (var s, o = n[1], l = new RegExp("(\\\\n|\\W)" + v(o) + p, "g"); s = l.exec(a);)"dll-reference" !== s[3] && i[r].push(s[3]); for (l = new RegExp("\\(" + v(o) + '\\("(dll-reference\\s(' + g + '))"\\)\\)' + p, "g"); s = l.exec(a);)e[s[2]] || (i[r].push(s[1]), e[s[2]] = f(s[1]).m), i[s[2]] = i[s[2]] || [], i[s[2]].push(s[4]); for (var u, d = Object.keys(i), c = 0; c < d.length; c++)for (var h = 0; h < i[d[c]].length; h++)u = i[d[c]][h], isNaN(+u) || (i[d[c]][h] = +i[d[c]][h]); return i } function u(e, t) { for (var r = { main: [t] }, i = { main: [] }, a = { main: {} }; function (r) { return Object.keys(r).reduce(function (e, t) { return e || 0 < r[t].length }, !1) }(r);)for (var n = Object.keys(r), s = 0; s < n.length; s++) { var o = n[s], l = r[o].pop(); if (a[o] = a[o] || {}, !a[o][l] && e[o][l]) { a[o][l] = !0, i[o] = i[o] || [], i[o].push(l); for (var u = h(e, e[o][l], o), d = Object.keys(u), c = 0; c < d.length; c++)r[d[c]] = r[d[c]] || [], r[d[c]] = r[d[c]].concat(u[d[c]]) } } return i } e.exports = function (e, t) { t = t || {}; var r = { main: f.m }, i = t.all ? { main: Object.keys(r.main) } : u(r, e), a = ""; Object.keys(i).filter(function (e) { return "main" !== e }).forEach(function (t) { for (var e = 0; i[t][e];)e++; i[t].push(e), r[t][e] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", a = a + "var " + t + " = (" + l.toString().replace("ENTRY_MODULE", JSON.stringify(e)) + ")({" + i[t].map(function (e) { return JSON.stringify(e) + ": " + r[t][e].toString() }).join(",") + "});\n" }), a = a + "new ((" + l.toString().replace("ENTRY_MODULE", JSON.stringify(e)) + ")({" + i.main.map(function (e) { return JSON.stringify(e) + ": " + r.main[e].toString() }).join(",") + "}))(self);"; var n = new window.Blob([a], { type: "text/javascript" }); if (t.bare) return n; var s = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(n), o = new window.Worker(s); return o.objectURL = s, o } }, "./src/crypt/decrypter.js": function (e, t, r) { "use strict"; r.r(t); var o = function () { function e(e, t) { this.subtle = e, this.aesIV = t } return e.prototype.decrypt = function (e, t) { return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e) }, e }(), l = function () { function e(e, t) { this.subtle = e, this.key = t } return e.prototype.expandKey = function () { return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]) }, e }(); var u = function () { function e() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable() } var t = e.prototype; return t.uint8ArrayToUint32Array_ = function (e) { for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < 4; i++)r[i] = t.getUint32(4 * i); return r }, t.initTable = function () { for (var e = this.sBox, t = this.invSBox, r = this.subMix, i = r[0], a = r[1], n = r[2], s = r[3], o = this.invSubMix, l = o[0], u = o[1], d = o[2], c = o[3], h = new Uint32Array(256), f = 0, g = 0, p = 0, p = 0; p < 256; p++)h[p] = p < 128 ? p << 1 : p << 1 ^ 283; for (p = 0; p < 256; p++) { var v = (v = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4) >>> 8 ^ 255 & v ^ 99, m = h[t[e[f] = v] = f], y = h[m], E = h[y], T = 257 * h[v] ^ 16843008 * v; i[f] = T << 24 | T >>> 8, a[f] = T << 16 | T >>> 16, n[f] = T << 8 | T >>> 24, s[f] = T, T = 16843009 * E ^ 65537 * y ^ 257 * m ^ 16843008 * f, l[v] = T << 24 | T >>> 8, u[v] = T << 16 | T >>> 16, d[v] = T << 8 | T >>> 24, c[v] = T, f ? (f = m ^ h[h[h[E ^ m]]], g ^= h[h[g]]) : f = g = 1 } }, t.expandKey = function (e) { for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r;)r = t[i] === this.key[i], i++; if (!r) { this.key = t; var a = this.keySize = t.length; if (4 !== a && 6 !== a && 8 !== a) throw new Error("Invalid aes key size=" + a); for (var n, s, o, l = this.ksRows = 4 * (a + 6 + 1), u = this.keySchedule = new Uint32Array(l), d = this.invKeySchedule = new Uint32Array(l), c = this.sBox, h = this.rcon, f = this.invSubMix, g = f[0], p = f[1], v = f[2], m = f[3], y = 0; y < l; y++)y < a ? s = u[y] = t[y] : (o = s, y % a == 0 ? (o = c[(o = o << 8 | o >>> 24) >>> 24] << 24 | c[o >>> 16 & 255] << 16 | c[o >>> 8 & 255] << 8 | c[255 & o], o ^= h[y / a | 0] << 24) : 6 < a && y % a == 4 && (o = c[o >>> 24] << 24 | c[o >>> 16 & 255] << 16 | c[o >>> 8 & 255] << 8 | c[255 & o]), u[y] = s = (u[y - a] ^ o) >>> 0); for (n = 0; n < l; n++)y = l - n, o = 3 & n ? u[y] : u[y - 4], d[n] = n < 4 || y <= 4 ? o : g[c[o >>> 24]] ^ p[c[o >>> 16 & 255]] ^ v[c[o >>> 8 & 255]] ^ m[c[255 & o]], d[n] = d[n] >>> 0 } }, t.networkToHostOrderSwap = function (e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 }, t.decrypt = function (e, t, r, i) { for (var a, n, s, o, l, u, d, c, h, f, g, p, v, m, y, E, T, b = this.keySize + 6, S = this.invKeySchedule, _ = this.invSBox, R = this.invSubMix, A = R[0], k = R[1], w = R[2], L = R[3], D = this.uint8ArrayToUint32Array_(r), O = D[0], C = D[1], I = D[2], x = D[3], P = new Int32Array(e), F = new Int32Array(P.length), M = this.networkToHostOrderSwap; t < P.length;) { for (h = M(P[t]), f = M(P[t + 1]), g = M(P[t + 2]), p = M(P[t + 3]), l = h ^ S[0], u = p ^ S[1], d = g ^ S[2], c = f ^ S[3], v = 4, m = 1; m < b; m++)a = A[l >>> 24] ^ k[u >> 16 & 255] ^ w[d >> 8 & 255] ^ L[255 & c] ^ S[v], n = A[u >>> 24] ^ k[d >> 16 & 255] ^ w[c >> 8 & 255] ^ L[255 & l] ^ S[v + 1], s = A[d >>> 24] ^ k[c >> 16 & 255] ^ w[l >> 8 & 255] ^ L[255 & u] ^ S[v + 2], o = A[c >>> 24] ^ k[l >> 16 & 255] ^ w[u >> 8 & 255] ^ L[255 & d] ^ S[v + 3], l = a, u = n, d = s, c = o, v += 4; a = _[l >>> 24] << 24 ^ _[u >> 16 & 255] << 16 ^ _[d >> 8 & 255] << 8 ^ _[255 & c] ^ S[v], n = _[u >>> 24] << 24 ^ _[d >> 16 & 255] << 16 ^ _[c >> 8 & 255] << 8 ^ _[255 & l] ^ S[v + 1], s = _[d >>> 24] << 24 ^ _[c >> 16 & 255] << 16 ^ _[l >> 8 & 255] << 8 ^ _[255 & u] ^ S[v + 2], o = _[c >>> 24] << 24 ^ _[l >> 16 & 255] << 16 ^ _[u >> 8 & 255] << 8 ^ _[255 & d] ^ S[v + 3], v += 3, F[t] = M(a ^ O), F[t + 1] = M(o ^ C), F[t + 2] = M(s ^ I), F[t + 3] = M(n ^ x), O = h, C = f, I = g, x = p, t += 4 } return i ? (y = F.buffer, E = y.byteLength, (T = E && new DataView(y).getUint8(E - 1)) ? y.slice(0, E - T) : y) : F.buffer }, t.destroy = function () { this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0 }, e }(), n = r("./src/errors.ts"), d = r("./src/utils/logger.js"), s = r("./src/events.js"), i = r("./src/utils/get-self-scope.js"), c = Object(i.getSelfScope)(), a = function () { function e(e, t, r) { var i = (void 0 === r ? {} : r).removePKCS7Padding, a = void 0 === i || i; if (this.logEnabled = !0, this.observer = e, this.config = t, this.removePKCS7Padding = a) try { var n = c.crypto; n && (this.subtle = n.subtle || n.webkitSubtle) } catch (e) { } this.disableWebCrypto = !this.subtle } var t = e.prototype; return t.isSync = function () { return this.disableWebCrypto && this.config.enableSoftwareAES }, t.decrypt = function (t, r, i, a) { var e, n, s = this; this.disableWebCrypto && this.config.enableSoftwareAES ? (this.logEnabled && (d.logger.log("JS AES decrypt"), this.logEnabled = !1), (e = this.decryptor) || (this.decryptor = e = new u), e.expandKey(r), a(e.decrypt(t, 0, i, this.removePKCS7Padding))) : (this.logEnabled && (d.logger.log("WebCrypto AES decrypt"), this.logEnabled = !1), n = this.subtle, this.key !== r && (this.key = r, this.fastAesKey = new l(n, r)), this.fastAesKey.expandKey().then(function (e) { new o(n, i).decrypt(t, e).catch(function (e) { s.onWebCryptoError(e, t, r, i, a) }).then(function (e) { a(e) }) }).catch(function (e) { s.onWebCryptoError(e, t, r, i, a) })) }, t.onWebCryptoError = function (e, t, r, i, a) { this.config.enableSoftwareAES ? (d.logger.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(t, r, i, a)) : (d.logger.error("decrypting error : " + e.message), this.observer.trigger(s.default.ERROR, { type: n.ErrorTypes.MEDIA_ERROR, details: n.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: !0, reason: e.message })) }, t.destroy = function () { var e = this.decryptor; e && (e.destroy(), this.decryptor = void 0) }, e }(); t.default = a }, "./src/demux/demuxer-inline.js": function (e, t, r) { "use strict"; r.r(t); var J = r("./src/events.js"), Z = r("./src/errors.ts"), p = r("./src/crypt/decrypter.js"), g = r("./src/polyfills/number-isFinite.js"), ee = r("./src/utils/logger.js"), i = r("./src/utils/get-self-scope.js"); function a(e, t) { return 255 === e[t] && 240 == (246 & e[t + 1]) } function d(e, t) { return 1 & e[t + 1] ? 7 : 9 } function c(e, t) { return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5 } function v(e, t) { return !!(t + 1 < e.length && a(e, t)) } function m(e, t, r, i, a) { var n; e.samplerate || (n = function (e, t, r, i) { var a, n, s, o = navigator.userAgent.toLowerCase(), l = i, u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], d = 1 + ((192 & t[r + 2]) >>> 6), c = (60 & t[r + 2]) >>> 2; if (!(u.length - 1 < c)) return n = (1 & t[r + 2]) << 2, n |= (192 & t[r + 3]) >>> 6, ee.logger.log("manifest codec:" + i + ",ADTS data:type:" + d + ",sampleingIndex:" + c + "[" + u[c] + "Hz],channelConfig:" + n), a = /firefox/i.test(o) ? 6 <= c ? (d = 5, s = new Array(4), c - 3) : (d = 2, s = new Array(2), c) : -1 !== o.indexOf("android") ? (d = 2, s = new Array(2), c) : (d = 5, s = new Array(4), i && (-1 !== i.indexOf("mp4a.40.29") || -1 !== i.indexOf("mp4a.40.5")) || !i && 6 <= c ? c - 3 : ((i && -1 !== i.indexOf("mp4a.40.2") && (6 <= c && 1 == n || /vivaldi/i.test(o)) || !i && 1 == n) && (d = 2, s = new Array(2)), c)), s[0] = d << 3, s[0] |= (14 & c) >> 1, s[1] |= (1 & c) << 7, s[1] |= n << 3, 5 === d && (s[1] |= (14 & a) >> 1, s[2] = (1 & a) << 7, s[2] |= 8, s[3] = 0), { config: s, samplerate: u[c], channelCount: n, codec: "mp4a.40." + d, manifestCodec: l }; e.trigger(J.default.ERROR, { type: Z.ErrorTypes.MEDIA_ERROR, details: Z.ErrorDetails.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + c }) }(t, r, i, a), e.config = n.config, e.samplerate = n.samplerate, e.channelCount = n.channelCount, e.codec = n.codec, e.manifestCodec = n.manifestCodec, ee.logger.log("parsed codec:" + e.codec + ",rate:" + n.samplerate + ",nb channel:" + n.channelCount)) } function y(e) { return 9216e4 / e } function E(e, t, r, i, a) { var n = function (e, t, r, i, a) { var n = e.length, s = d(e, t), o = c(e, t); if (0 < (o -= s) && t + s + o <= n) return { headerLength: s, frameLength: o, stamp: r + i * a } }(t, r, i, a, y(e.samplerate)); if (n) { var s = n.stamp, o = n.headerLength, l = n.frameLength, u = { unit: t.subarray(r + o, r + o + l), pts: s, dts: s }; return e.samples.push(u), { sample: u, length: l + o } } } var w = r("./src/demux/id3.js"), _ = function () { function e(e, t, r) { this.observer = e, this.config = r, this.remuxer = t } var t = e.prototype; return t.resetInitSegment = function (e, t, r, i) { this._audioTrack = { container: "audio/adts", type: "audio", id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: t, duration: i, inputTimeScale: 9e4 } }, t.resetTimeStamp = function () { }, e.probe = function (e) { if (!e) return !1; for (var t = (w.default.getID3Data(e, 0) || []).length, r = e.length; t < r; t++)if (function (e, t) { if (v(e, t)) { var r = d(e, t); t + 5 < e.length && (r = c(e, t)); var i = t + r; if (i === e.length || i + 1 < e.length && a(e, i)) return 1 } }(e, t)) return ee.logger.log("ADTS sync word found !"), !0; return !1 }, t.append = function (e, t, r, i) { for (var a = this._audioTrack, n = w.default.getID3Data(e, 0) || [], s = w.default.getTimeStamp(n), o = Object(g.isFiniteNumber)(s) ? 90 * s : 9e4 * t, l = 0, u = o, d = e.length, c = n.length, h = [{ pts: u, dts: u, data: n }]; c < d - 1;)if (v(e, c) && c + 5 < d) { m(a, this.observer, e, c, a.manifestCodec); var f = E(a, e, c, o, l); if (!f) { ee.logger.log("Unable to parse AAC frame"); break } c += f.length, u = f.sample.pts, l++ } else w.default.isHeader(e, c) ? (n = w.default.getID3Data(e, c), h.push({ pts: u, dts: u, data: n }), c += n.length) : c++; this.remuxer.remux(a, { samples: [] }, { samples: h, inputTimeScale: 9e4 }, { samples: [] }, t, r, i) }, t.destroy = function () { }, e }(), R = r("./src/demux/mp4demuxer.js"), T = { BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], SamplesCoefficients: [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], BytesInSlot: [0, 1, 1, 4], appendFrame: function (e, t, r, i, a) { if (!(r + 24 > t.length)) { var n = this.parseHeader(t, r); if (n && r + n.frameLength <= t.length) { var s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate), o = { unit: t.subarray(r, r + n.frameLength), pts: s, dts: s }; return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(o), { sample: o, length: n.frameLength } } } }, parseHeader: function (e, t) { var r = e[t + 1] >> 3 & 3, i = e[t + 1] >> 1 & 3, a = e[t + 2] >> 4 & 15, n = e[t + 2] >> 2 & 3, s = e[t + 2] >> 1 & 1; if (1 != r && 0 != a && 15 != a && 3 != n) { var o = 3 == r ? 3 - i : 3 == i ? 3 : 4, l = 1e3 * T.BitratesMap[14 * o + a - 1], u = 3 == r ? 0 : 2 == r ? 1 : 2, d = T.SamplingRateMap[3 * u + n], c = e[t + 3] >> 6 == 3 ? 1 : 2, h = T.SamplesCoefficients[r][i], f = T.BytesInSlot[i], g = 8 * h * f; return { sampleRate: d, channelCount: c, frameLength: parseInt(h * l / d + s, 10) * f, samplesPerFrame: g } } }, isHeaderPattern: function (e, t) { return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1]) }, isHeader: function (e, t) { return !!(t + 1 < e.length && this.isHeaderPattern(e, t)) }, probe: function (e, t) { if (t + 1 < e.length && this.isHeaderPattern(e, t)) { var r = this.parseHeader(e, t), i = 4; r && r.frameLength && (i = r.frameLength); var a = t + i; if (a === e.length || a + 1 < e.length && this.isHeaderPattern(e, a)) return !0 } return !1 } }, b = T, L = function () { function e(e) { this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 } var t = e.prototype; return t.loadWord = function () { var e = this.data, t = this.bytesAvailable, r = e.byteLength - t, i = new Uint8Array(4), a = Math.min(4, t); if (0 === a) throw new Error("no bytes available"); i.set(e.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a }, t.skipBits = function (e) { var t; this.bitsAvailable > e || (e -= this.bitsAvailable, e -= (t = e >> 3) >> 3, this.bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e }, t.readBits = function (e) { var t = Math.min(this.bitsAvailable, e), r = this.word >>> 32 - t; return 32 < e && ee.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, 0 < this.bitsAvailable ? this.word <<= t : 0 < this.bytesAvailable && this.loadWord(), 0 < (t = e - t) && this.bitsAvailable ? r << t | this.readBits(t) : r }, t.skipLZ = function () { for (var e = 0; e < this.bitsAvailable; ++e)if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() }, t.skipUEG = function () { this.skipBits(1 + this.skipLZ()) }, t.skipEG = function () { this.skipBits(1 + this.skipLZ()) }, t.readUEG = function () { var e = this.skipLZ(); return this.readBits(e + 1) - 1 }, t.readEG = function () { var e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }, t.readBoolean = function () { return 1 === this.readBits(1) }, t.readUByte = function () { return this.readBits(8) }, t.readUShort = function () { return this.readBits(16) }, t.readUInt = function () { return this.readBits(32) }, t.skipScalingList = function (e) { for (var t = 8, r = 8, i = 0; i < e; i++)0 !== r && (r = (t + this.readEG() + 256) % 256), t = 0 === r ? t : r }, t.readSPS = function () { var e, t, r, i, a, n, s, o = 0, l = 0, u = 0, d = 0, c = this.readUByte.bind(this), h = this.readBits.bind(this), f = this.readUEG.bind(this), g = this.readBoolean.bind(this), p = this.skipBits.bind(this), v = this.skipEG.bind(this), m = this.skipUEG.bind(this), y = this.skipScalingList.bind(this); if (c(), e = c(), h(5), p(3), c(), m(), 100 === e || 110 === e || 122 === e || 244 === e || 44 === e || 83 === e || 86 === e || 118 === e || 128 === e) { var E = f(); if (3 === E && p(1), m(), m(), p(1), g()) for (n = 3 !== E ? 8 : 12, s = 0; s < n; s++)g() && y(s < 6 ? 16 : 64) } m(); var T = f(); if (0 === T) f(); else if (1 === T) for (p(1), v(), v(), t = f(), s = 0; s < t; s++)v(); m(), p(1), r = f(), i = f(), 0 === (a = h(1)) && p(1), p(1), g() && (o = f(), l = f(), u = f(), d = f()); var b = [1, 1]; if (g() && g()) switch (c()) { case 1: b = [1, 1]; break; case 2: b = [12, 11]; break; case 3: b = [10, 11]; break; case 4: b = [16, 11]; break; case 5: b = [40, 33]; break; case 6: b = [24, 11]; break; case 7: b = [20, 11]; break; case 8: b = [32, 11]; break; case 9: b = [80, 33]; break; case 10: b = [18, 11]; break; case 11: b = [15, 11]; break; case 12: b = [64, 33]; break; case 13: b = [160, 99]; break; case 14: b = [4, 3]; break; case 15: b = [3, 2]; break; case 16: b = [2, 1]; break; case 255: b = [c() << 8 | c(), c() << 8 | c()] }return { width: Math.ceil(16 * (r + 1) - 2 * o - 2 * l), height: (2 - a) * (i + 1) * 16 - (a ? 2 : 4) * (u + d), pixelRatio: b } }, t.readSliceType = function () { return this.readUByte(), this.readUEG(), this.readUEG() }, e }(), n = function () { function e(e, t, r, i) { this.decryptdata = r, this.discardEPB = i, this.decrypter = new p.default(e, t, { removePKCS7Padding: !1 }) } var t = e.prototype; return t.decryptBuffer = function (e, t) { this.decrypter.decrypt(e, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, t) }, t.decryptAacSample = function (t, r, i, a) { var n = t[r].unit, e = n.subarray(16, n.length - n.length % 16), s = e.buffer.slice(e.byteOffset, e.byteOffset + e.length), o = this; this.decryptBuffer(s, function (e) { e = new Uint8Array(e), n.set(e, 16), a || o.decryptAacSamples(t, r + 1, i) }) }, t.decryptAacSamples = function (e, t, r) { for (; ; t++) { if (t >= e.length) return void r(); if (!(e[t].unit.length < 32)) { var i = this.decrypter.isSync(); if (this.decryptAacSample(e, t, r, i), !i) return } } }, t.getAvcEncryptedData = function (e) { for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), i = 0, a = 32; a <= e.length - 16; a += 160, i += 16)r.set(e.subarray(a, a + 16), i); return r }, t.getAvcDecryptedUnit = function (e, t) { t = new Uint8Array(t); for (var r = 0, i = 32; i <= e.length - 16; i += 160, r += 16)e.set(t.subarray(r, r + 16), i); return e }, t.decryptAvcSample = function (t, r, i, a, n, s) { var o = this.discardEPB(n.data), e = this.getAvcEncryptedData(o), l = this; this.decryptBuffer(e.buffer, function (e) { n.data = l.getAvcDecryptedUnit(o, e), s || l.decryptAvcSamples(t, r, i + 1, a) }) }, t.decryptAvcSamples = function (e, t, r, i) { for (; ; t++, r = 0) { if (t >= e.length) return void i(); for (var a = e[t].units; !(r >= a.length); r++) { var n = a[r]; if (!(n.length <= 48 || 1 !== n.type && 5 !== n.type)) { var s = this.decrypter.isSync(); if (this.decryptAvcSample(e, t, r, i, n, s), !s) return } } } }, e }(), s = { video: 1, audio: 2, id3: 3, text: 4 }, A = function () { function C(e, t, r, i) { this.observer = e, this.config = r, this.typeSupported = i, this.remuxer = t, this.sampleAes = null } var e = C.prototype; return e.setDecryptData = function (e) { null != e && null != e.key && "SAMPLE-AES" === e.method ? this.sampleAes = new n(this.observer, this.config, e, this.discardEPB) : this.sampleAes = null }, C.probe = function (e) { var t = C._syncOffset(e); return !(t < 0) && (t && ee.logger.warn("MPEG2-TS detected but first sync word found @ offset " + t + ", junk ahead ?"), !0) }, C._syncOffset = function (e) { for (var t = Math.min(1e3, e.length - 564), r = 0; r < t;) { if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376]) return r; r++ } return -1 }, C.createTrack = function (e, t) { return { container: "video" === e || "audio" === e ? "video/mp2t" : void 0, type: e, id: s[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: "video" === e ? 0 : void 0, isAAC: "audio" === e || void 0, duration: "audio" === e ? t : void 0 } }, e.resetInitSegment = function (e, t, r, i) { this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = C.createTrack("video", i), this._audioTrack = C.createTrack("audio", i), this._id3Track = C.createTrack("id3", i), this._txtTrack = C.createTrack("text", i), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = t, this.videoCodec = r, this._duration = i }, e.resetTimeStamp = function () { }, e.append = function (e, t, r, i) { var a, n, s, o, l, u = e.length, d = !1; this.contiguous = r; var c = this.pmtParsed, h = this._avcTrack, f = this._audioTrack, g = this._id3Track, p = h.pid, v = f.pid, m = g.pid, y = this._pmtId, E = h.pesData, T = f.pesData, b = g.pesData, S = this._parsePAT, _ = this._parsePMT, R = this._parsePES, A = this._parseAVCPES.bind(this), k = this._parseAACPES.bind(this), w = this._parseMPEGPES.bind(this), L = this._parseID3PES.bind(this), D = C._syncOffset(e); for (u -= (u + D) % 188, a = D; a < u; a += 188)if (71 === e[a]) { if (n = !!(64 & e[a + 1]), s = ((31 & e[a + 1]) << 8) + e[a + 2], 1 < (48 & e[a + 3]) >> 4) { if ((o = a + 5 + e[a + 4]) === a + 188) continue } else o = a + 4; switch (s) { case p: n && (E && (l = R(E)) && A(l, !1), E = { data: [], size: 0 }), E && (E.data.push(e.subarray(o, a + 188)), E.size += a + 188 - o); break; case v: n && (T && (l = R(T)) && (f.isAAC ? k : w)(l), T = { data: [], size: 0 }), T && (T.data.push(e.subarray(o, a + 188)), T.size += a + 188 - o); break; case m: n && (b && (l = R(b)) && L(l), b = { data: [], size: 0 }), b && (b.data.push(e.subarray(o, a + 188)), b.size += a + 188 - o); break; case 0: n && (o += e[o] + 1), y = this._pmtId = S(e, o); break; case y: n && (o += e[o] + 1); var O = _(e, o, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, null != this.sampleAes); 0 < (p = O.avc) && (h.pid = p), 0 < (v = O.audio) && (f.pid = v, f.isAAC = O.isAAC), 0 < (m = O.id3) && (g.pid = m), d && !c && (ee.logger.log("reparse from beginning"), d = !1, a = D - 188), c = this.pmtParsed = !0; break; case 17: case 8191: break; default: d = !0 } } else this.observer.trigger(J.default.ERROR, { type: Z.ErrorTypes.MEDIA_ERROR, details: Z.ErrorDetails.FRAG_PARSING_ERROR, fatal: !1, reason: "TS packet did not start with 0x47" }); E && (l = R(E)) ? (A(l, !0), h.pesData = null) : h.pesData = E, T && (l = R(T)) ? ((f.isAAC ? k : w)(l), f.pesData = null) : (T && T.size && ee.logger.log("last AAC PES packet truncated,might overlap between fragments"), f.pesData = T), b && (l = R(b)) ? (L(l), g.pesData = null) : g.pesData = b, null == this.sampleAes ? this.remuxer.remux(f, h, g, this._txtTrack, t, r, i) : this.decryptAndRemux(f, h, g, this._txtTrack, t, r, i) }, e.decryptAndRemux = function (e, t, r, i, a, n, s) { var o; e.samples && e.isAAC ? (o = this).sampleAes.decryptAacSamples(e.samples, 0, function () { o.decryptAndRemuxAvc(e, t, r, i, a, n, s) }) : this.decryptAndRemuxAvc(e, t, r, i, a, n, s) }, e.decryptAndRemuxAvc = function (e, t, r, i, a, n, s) { var o; t.samples ? (o = this).sampleAes.decryptAvcSamples(t.samples, 0, 0, function () { o.remuxer.remux(e, t, r, i, a, n, s) }) : this.remuxer.remux(e, t, r, i, a, n, s) }, e.destroy = function () { this._initPTS = this._initDTS = void 0, this._duration = 0 }, e._parsePAT = function (e, t) { return (31 & e[t + 10]) << 8 | e[t + 11] }, e._parsePMT = function (e, t, r, i) { var a, n = { audio: -1, avc: -1, id3: -1, isAAC: !0 }, s = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4; for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < s;) { switch (a = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) { case 207: if (!i) { ee.logger.log("unknown stream type:" + e[t]); break } case 15: -1 === n.audio && (n.audio = a); break; case 21: -1 === n.id3 && (n.id3 = a); break; case 219: if (!i) { ee.logger.log("unknown stream type:" + e[t]); break } case 27: -1 === n.avc && (n.avc = a); break; case 3: case 4: r ? -1 === n.audio && (n.audio = a, n.isAAC = !1) : ee.logger.log("MPEG audio found, not supported in this browser for now"); break; case 36: ee.logger.warn("HEVC stream type found, not supported for now"); break; default: ee.logger.log("unknown stream type:" + e[t]) }t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4]) } return n }, e._parsePES = function (e) { var t, r, i, a, n, s, o, l, u = 0, d = e.data; if (!e || 0 === e.size) return null; for (; d[0].length < 19 && 1 < d.length;) { var c = new Uint8Array(d[0].length + d[1].length); c.set(d[0]), c.set(d[1], d[0].length), d[0] = c, d.splice(1, 1) } if (1 !== ((t = d[0])[0] << 16) + (t[1] << 8) + t[2]) return null; if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null; if (192 & (r = t[7]) && (4294967295 < (s = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2) && (s -= 8589934592), 64 & r ? (4294967295 < (o = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) && (o -= 8589934592), 54e5 < s - o && (ee.logger.warn(Math.round((s - o) / 9e4) + "s delta between PTS and DTS, align them"), s = o)) : o = s), l = (a = t[8]) + 9, e.size <= l) return null; e.size -= l, n = new Uint8Array(e.size); for (var h = 0, f = d.length; h < f; h++) { var g = (t = d[h]).byteLength; if (l) { if (g < l) { l -= g; continue } t = t.subarray(l), g -= l, l = 0 } n.set(t, u), u += g } return i && (i -= a + 3), { data: n, pts: s, dts: o, len: i } }, e.pushAccesUnit = function (e, t) { if (e.units.length && e.frame) { var r = t.samples, i = r.length; if (isNaN(e.pts)) { if (!i) return void t.dropped++; var a = r[i - 1]; e.pts = a.pts, e.dts = a.dts } !this.config.forceKeyFrameOnDiscontinuity || !0 === e.key || t.sps && (i || this.contiguous) ? (e.id = i, r.push(e)) : t.dropped++ } e.debug.length && ee.logger.log(e.pts + "/" + e.dts + ":" + e.debug) }, e._parseAVCPES = function (m, e) { function y(e, t, r, i) { return { key: e, pts: t, dts: r, units: [], debug: i } } var E, T, b, S = this, _ = this._avcTrack, t = this._parseAVCNALu(m.data), R = this.avcSample, A = !1, k = this.pushAccesUnit.bind(this); m.data = null, R && t.length && !_.audFound && (k(R, _), R = this.avcSample = y(!1, m.pts, m.dts, "")), t.forEach(function (e) { switch (e.type) { case 1: T = !0, (R = R || (S.avcSample = y(!0, m.pts, m.dts, ""))).frame = !0; var t, r = e.data; A && 4 < r.length && (2 !== (t = new L(r).readSliceType()) && 4 !== t && 7 !== t && 9 !== t || (R.key = !0)); break; case 5: T = !0, (R = R || (S.avcSample = y(!0, m.pts, m.dts, ""))).key = !0, R.frame = !0; break; case 6: T = !0, (E = new L(S.discardEPB(e.data))).readUByte(); for (var i = 0, a = 0, n = !1, s = 0; !n && 1 < E.bytesAvailable;) { for (i = 0; i += s = E.readUByte(), 255 === s;); for (a = 0; a += s = E.readUByte(), 255 === s;); if (4 === i && 0 !== E.bytesAvailable) { n = !0; if (181 === E.readUByte()) if (49 === E.readUShort()) if (1195456820 === E.readUInt()) if (3 === E.readUByte()) { var o = E.readUByte(), l = 31 & o, u = [o, E.readUByte()]; for (b = 0; b < l; b++)u.push(E.readUByte()), u.push(E.readUByte()), u.push(E.readUByte()); S._insertSampleInOrder(S._txtTrack.samples, { type: 3, pts: m.pts, bytes: u }) } } else if (5 === i && 0 !== E.bytesAvailable) { if (n = !0, 16 < a) { var d = []; for (b = 0; b < 16; b++)d.push(E.readUByte().toString(16)), 3 !== b && 5 !== b && 7 !== b && 9 !== b || d.push("-"); var c = a - 16, h = new Uint8Array(c); for (b = 0; b < c; b++)h[b] = E.readUByte(); S._insertSampleInOrder(S._txtTrack.samples, { pts: m.pts, payloadType: i, uuid: d.join(""), userDataBytes: h, userData: Object(w.utf8ArrayToStr)(h.buffer) }) } } else if (a < E.bytesAvailable) for (b = 0; b < a; b++)E.readUByte() } break; case 7: if (A = T = !0, !_.sps) { var f = (E = new L(e.data)).readSPS(); _.width = f.width, _.height = f.height, _.pixelRatio = f.pixelRatio, _.sps = [e.data], _.duration = S._duration; var g = e.data.subarray(1, 4), p = "avc1."; for (b = 0; b < 3; b++) { var v = g[b].toString(16); v.length < 2 && (v = "0" + v), p += v } _.codec = p } break; case 8: T = !0, _.pps || (_.pps = [e.data]); break; case 9: T = !1, _.audFound = !0, R && k(R, _), R = S.avcSample = y(!1, m.pts, m.dts, ""); break; case 12: T = !1; break; default: T = !1, R && (R.debug += "unknown NAL " + e.type + " ") }R && T && R.units.push(e) }), e && R && (k(R, _), this.avcSample = null) }, e._insertSampleInOrder = function (e, t) { var r = e.length; if (0 < r) { if (t.pts >= e[r - 1].pts) e.push(t); else for (var i = r - 1; 0 <= i; i--)if (t.pts < e[i].pts) { e.splice(i, 0, t); break } } else e.push(t) }, e._getLastNalUnit = function () { var e, t, r, i = this.avcSample; return i && 0 !== i.units.length || (i = (e = this._avcTrack.samples)[e.length - 1]), i && (r = (t = i.units)[t.length - 1]), r }, e._parseAVCNALu = function (e) { var t, r, i, a, n, s = 0, o = e.byteLength, l = this._avcTrack, u = g = l.naluState || 0, d = [], c = -1; for (-1 === g && (i = 31 & e[c = 0], g = 0, s = 1); s < o;) { var h, f, g, p = e[s++]; g ? g = 1 !== g ? p ? 1 === p ? (0 <= c ? (r = { data: e.subarray(c, s - g - 1), type: i }, d.push(r)) : (h = this._getLastNalUnit()) && (u && s <= 4 - u && h.state && (h.data = h.data.subarray(0, h.data.byteLength - u)), 0 < (t = s - g - 1) && ((f = new Uint8Array(h.data.byteLength + t)).set(h.data, 0), f.set(e.subarray(0, t), h.data.byteLength), h.data = f)), s < o ? (i = 31 & e[c = s], 0) : -1) : 0 : 3 : p ? 0 : 2 : g = p ? 0 : 1 } return 0 <= c && 0 <= g && (r = { data: e.subarray(c, o), type: i, state: g }, d.push(r)), 0 !== d.length || (a = this._getLastNalUnit()) && ((n = new Uint8Array(a.data.byteLength + e.byteLength)).set(a.data, 0), n.set(e, a.data.byteLength), a.data = n), l.naluState = g, d }, e.discardEPB = function (e) { for (var t, r, i = e.byteLength, a = [], n = 1; n < i - 2;)0 === e[n] && 0 === e[n + 1] && 3 === e[n + 2] ? (a.push(n + 2), n += 2) : n++; if (0 === a.length) return e; t = i - a.length, r = new Uint8Array(t); for (var s = 0, n = 0; n < t; s++, n++)s === a[0] && (s++, a.shift()), r[n] = e[s]; return r }, e._parseAACPES = function (e) { var t, r, i, a, n, s, o, l = this._audioTrack, u = e.data, d = e.pts, c = this.aacOverFlow, h = this.aacLastPTS; for (c && ((s = new Uint8Array(c.byteLength + u.byteLength)).set(c, 0), s.set(u, c.byteLength), u = s), i = 0, n = u.length; i < n - 1 && !v(u, i); i++); if (i) { var f, g = i < n - 1 ? (f = "AAC PES did not start with ADTS header,offset:" + i, !1) : (f = "no ADTS header found in AAC PES", !0); if (ee.logger.warn("parsing error:" + f), this.observer.trigger(J.default.ERROR, { type: Z.ErrorTypes.MEDIA_ERROR, details: Z.ErrorDetails.FRAG_PARSING_ERROR, fatal: g, reason: f }), g) return } for (m(l, this.observer, u, i, this.audioCodec), r = 0, t = y(l.samplerate), c && h && (o = h + t, 1 < Math.abs(o - d) && (ee.logger.log("AAC: align PTS for overlapping frames by " + Math.round((o - d) / 90)), d = o)); i < n;) { if (v(u, i)) { if (i + 5 < n) { var p = E(l, u, i, d, r); if (p) { i += p.length, a = p.sample.pts, r++; continue } } break } i++ } c = i < n ? u.subarray(i, n) : null, this.aacOverFlow = c, this.aacLastPTS = a }, e._parseMPEGPES = function (e) { for (var t = e.data, r = t.length, i = 0, a = 0, n = e.pts; a < r;)if (b.isHeader(t, a)) { var s = b.appendFrame(this._audioTrack, t, a, n, i); if (!s) break; a += s.length, i++ } else a++ }, e._parseID3PES = function (e) { this._id3Track.samples.push(e) }, C }(), k = function () { function e(e, t, r) { this.observer = e, this.config = r, this.remuxer = t } var t = e.prototype; return t.resetInitSegment = function (e, t, r, i) { this._audioTrack = { container: "audio/mpeg", type: "audio", id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: t, duration: i, inputTimeScale: 9e4 } }, t.resetTimeStamp = function () { }, e.probe = function (e) { var t, r, i = w.default.getID3Data(e, 0); if (i && void 0 !== w.default.getTimeStamp(i)) for (t = i.length, r = Math.min(e.length - 1, t + 100); t < r; t++)if (b.probe(e, t)) return ee.logger.log("MPEG Audio sync word found !"), !0; return !1 }, t.append = function (e, t, r, i) { for (var a = w.default.getID3Data(e, 0), n = w.default.getTimeStamp(a), s = n ? 90 * n : 9e4 * t, o = a.length, l = e.length, u = 0, d = 0, c = this._audioTrack, h = [{ pts: s, dts: s, data: a }]; o < l;)if (b.isHeader(e, o)) { var f = b.appendFrame(c, e, o, s, u); if (!f) break; o += f.length, d = f.sample.pts, u++ } else w.default.isHeader(e, o) ? (a = w.default.getID3Data(e, o), h.push({ pts: d, dts: d, data: a }), o += a.length) : o++; this.remuxer.remux(c, { samples: [] }, { samples: h, inputTimeScale: 9e4 }, { samples: [] }, t, r, i) }, t.destroy = function () { }, e }(), V = function () { function e() { } return e.getSilentFrame = function (e, t) { switch (e) { case "mp4a.40.2": if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]); break; default: if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) }return null }, e }(), o = Math.pow(2, 32) - 1, te = function () { function h() { } return h.init = function () { var e; for (e in h.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }) h.types.hasOwnProperty(e) && (h.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); h.HDLR_TYPES = { video: t, audio: r }; var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); h.STTS = h.STSC = h.STCO = a, h.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), h.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), h.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), h.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); var n = new Uint8Array([105, 115, 111, 109]), s = new Uint8Array([97, 118, 99, 49]), o = new Uint8Array([0, 0, 0, 1]); h.FTYP = h.box(h.types.ftyp, n, o, n, s), h.DINF = h.box(h.types.dinf, h.box(h.types.dref, i)) }, h.box = function (e) { for (var t, r = Array.prototype.slice.call(arguments, 1), i = 8, a = r.length, n = a; a--;)i += r[a].byteLength; for ((t = new Uint8Array(i))[0] = i >> 24 & 255, t[1] = i >> 16 & 255, t[2] = i >> 8 & 255, t[3] = 255 & i, t.set(e, 4), a = 0, i = 8; a < n; a++)t.set(r[a], i), i += r[a].byteLength; return t }, h.hdlr = function (e) { return h.box(h.types.hdlr, h.HDLR_TYPES[e]) }, h.mdat = function (e) { return h.box(h.types.mdat, e) }, h.mdhd = function (e, t) { t *= e; var r = Math.floor(t / (1 + o)), i = Math.floor(t % (1 + o)); return h.box(h.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 85, 196, 0, 0])) }, h.mdia = function (e) { return h.box(h.types.mdia, h.mdhd(e.timescale, e.duration), h.hdlr(e.type), h.minf(e)) }, h.mfhd = function (e) { return h.box(h.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e])) }, h.minf = function (e) { return "audio" === e.type ? h.box(h.types.minf, h.box(h.types.smhd, h.SMHD), h.DINF, h.stbl(e)) : h.box(h.types.minf, h.box(h.types.vmhd, h.VMHD), h.DINF, h.stbl(e)) }, h.moof = function (e, t, r) { return h.box(h.types.moof, h.mfhd(e), h.traf(r, t)) }, h.moov = function (e) { for (var t = e.length, r = []; t--;)r[t] = h.trak(e[t]); return h.box.apply(null, [h.types.moov, h.mvhd(e[0].timescale, e[0].duration)].concat(r).concat(h.mvex(e))) }, h.mvex = function (e) { for (var t = e.length, r = []; t--;)r[t] = h.trex(e[t]); return h.box.apply(null, [h.types.mvex].concat(r)) }, h.mvhd = function (e, t) { t *= e; var r = Math.floor(t / (1 + o)), i = Math.floor(t % (1 + o)), a = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return h.box(h.types.mvhd, a) }, h.sdtp = function (e) { for (var t, r = e.samples || [], i = new Uint8Array(4 + r.length), a = 0; a < r.length; a++)t = r[a].flags, i[a + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy; return h.box(h.types.sdtp, i) }, h.stbl = function (e) { return h.box(h.types.stbl, h.stsd(e), h.box(h.types.stts, h.STTS), h.box(h.types.stsc, h.STSC), h.box(h.types.stsz, h.STSZ), h.box(h.types.stco, h.STCO)) }, h.avc1 = function (e) { for (var t, r, i = [], a = [], n = 0; n < e.sps.length; n++)r = (t = e.sps[n]).byteLength, i.push(r >>> 8 & 255), i.push(255 & r), i = i.concat(Array.prototype.slice.call(t)); for (n = 0; n < e.pps.length; n++)r = (t = e.pps[n]).byteLength, a.push(r >>> 8 & 255), a.push(255 & r), a = a.concat(Array.prototype.slice.call(t)); var s = h.box(h.types.avcC, new Uint8Array([1, i[3], i[4], i[5], 255, 224 | e.sps.length].concat(i).concat([e.pps.length]).concat(a))), o = e.width, l = e.height, u = e.pixelRatio[0], d = e.pixelRatio[1]; return h.box(h.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), s, h.box(h.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), h.box(h.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d]))) }, h.esds = function (e) { var t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])) }, h.mp4a = function (e) { var t = e.samplerate; return h.box(h.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), h.box(h.types.esds, h.esds(e))) }, h.mp3 = function (e) { var t = e.samplerate; return h.box(h.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0])) }, h.stsd = function (e) { return "audio" === e.type ? e.isAAC || "mp3" !== e.codec ? h.box(h.types.stsd, h.STSD, h.mp4a(e)) : h.box(h.types.stsd, h.STSD, h.mp3(e)) : h.box(h.types.stsd, h.STSD, h.avc1(e)) }, h.tkhd = function (e) { var t = e.id, r = e.duration * e.timescale, i = e.width, a = e.height, n = Math.floor(r / (1 + o)), s = Math.floor(r % (1 + o)); return h.box(h.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i >> 8 & 255, 255 & i, 0, 0, a >> 8 & 255, 255 & a, 0, 0])) }, h.traf = function (e, t) { var r = h.sdtp(e), i = e.id, a = Math.floor(t / (1 + o)), n = Math.floor(t % (1 + o)); return h.box(h.types.traf, h.box(h.types.tfhd, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i])), h.box(h.types.tfdt, new Uint8Array([1, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), h.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8), r) }, h.trak = function (e) { return e.duration = e.duration || 4294967295, h.box(h.types.trak, h.tkhd(e), h.mdia(e)) }, h.trex = function (e) { var t = e.id; return h.box(h.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) }, h.trun = function (e, t) { var r, i, a, n, s, o, l = e.samples || [], u = l.length, d = 12 + 16 * u, c = new Uint8Array(d); for (t += 8 + d, c.set([0, 0, 15, 1, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), r = 0; r < u; r++)a = (i = l[r]).duration, n = i.size, s = i.flags, o = i.cts, c.set([a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s.isLeading << 2 | s.dependsOn, s.isDependedOn << 6 | s.hasRedundancy << 4 | s.paddingValue << 1 | s.isNonSync, 61440 & s.degradPrio, 15 & s.degradPrio, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o], 12 + 16 * r); return h.box(h.types.trun, c) }, h.initSegment = function (e) { h.types || h.init(); var t = h.moov(e), r = new Uint8Array(h.FTYP.byteLength + t.byteLength); return r.set(h.FTYP), r.set(t, h.FTYP.byteLength), r }, h }(); function l(e, t, r, i) { void 0 === r && (r = 1), void 0 === i && (i = !1); var a = e * t * r; return i ? Math.round(a) : a } function re(e, t) { return void 0 === t && (t = !1), l(e, 1e3, 1 / 9e4, t) } function u(e, t) { return void 0 === t && (t = 1), l(e, 9e4, 1 / t) } var S, Y = u(10), ie = u(.2), D = function () { function e(e, t, r, i) { this.observer = e, this.config = t, this.typeSupported = r; var a = navigator.userAgent; this.isSafari = i && -1 < i.indexOf("Apple") && a && !a.match("CriOS"), this.ISGenerated = !1 } var t = e.prototype; return t.destroy = function () { }, t.resetTimeStamp = function (e) { this._initPTS = this._initDTS = e }, t.resetInitSegment = function () { this.ISGenerated = !1 }, t.remux = function (e, t, r, i, a, n, s) { var o, l, u, d, c, h, f, g; this.ISGenerated || this.generateIS(e, t, a), this.ISGenerated && (o = e.samples.length, l = t.samples.length, d = u = a, o && l && (c = (e.samples[0].pts - t.samples[0].pts) / t.inputTimeScale, u += Math.max(0, c), d += Math.max(0, -c)), o ? (e.timescale || (ee.logger.warn("regenerate InitSegment as audio detected"), this.generateIS(e, t, a)), h = this.remuxAudio(e, u, n, s), l && (h && (f = h.endPTS - h.startPTS), t.timescale || (ee.logger.warn("regenerate InitSegment as video detected"), this.generateIS(e, t, a)), this.remuxVideo(t, d, n, f, s))) : !l || (g = this.remuxVideo(t, d, n, 0, s)) && e.codec && this.remuxEmptyAudio(e, u, n, g)), r.samples.length && this.remuxID3(r, a), i.samples.length && this.remuxText(i, a), this.observer.trigger(J.default.FRAG_PARSED) }, t.generateIS = function (e, t, r) { var i, a, n, s = this.observer, o = e.samples, l = t.samples, u = this.typeSupported, d = "audio/mp4", c = {}, h = { tracks: c }, f = void 0 === this._initPTS; f && (i = a = 1 / 0), e.config && o.length && (e.timescale = e.samplerate, ee.logger.log("audio sampling rate : " + e.samplerate), e.isAAC || (u.mpeg ? (d = "audio/mpeg", e.codec = "") : u.mp3 && (e.codec = "mp3")), c.audio = { container: d, codec: e.codec, initSegment: !e.isAAC && u.mpeg ? new Uint8Array : te.initSegment([e]), metadata: { channelCount: e.channelCount } }, f && (i = a = o[0].pts - e.inputTimeScale * r)), t.sps && t.pps && l.length && (n = t.inputTimeScale, t.timescale = n, c.video = { container: "video/mp4", codec: t.codec, initSegment: te.initSegment([t]), metadata: { width: t.width, height: t.height } }, f && (i = Math.min(i, l[0].pts - n * r), a = Math.min(a, l[0].dts - n * r), this.observer.trigger(J.default.INIT_PTS_FOUND, { initPTS: i }))), Object.keys(c).length ? (s.trigger(J.default.FRAG_PARSING_INIT_SEGMENT, h), this.ISGenerated = !0, f && (this._initPTS = i, this._initDTS = a)) : s.trigger(J.default.ERROR, { type: Z.ErrorTypes.MEDIA_ERROR, details: Z.ErrorDetails.FRAG_PARSING_ERROR, fatal: !1, reason: "no audio/video samples found" }) }, t.remuxVideo = function (e, t, r, i, a) { var n, s, o, l, u, d = 8, c = e.timescale, h = e.samples, f = [], g = h.length, p = this._PTSNormalize, v = this._initPTS, m = this.nextAvcDts, y = this.isSafari; if (0 !== g) { y && (r |= h.length && m && (a && Math.abs(t - m / c) < .1 || Math.abs(h[0].pts - m - v) < c / 5)), r || (m = t * c), h.forEach(function (e) { e.pts = p(e.pts - v, m), e.dts = p(e.dts - v, m) }), h.sort(function (e, t) { var r = e.dts - t.dts, i = e.pts - t.pts; return r || i || e.id - t.id }); var E = h.reduce(function (e, t) { return Math.max(Math.min(e, t.pts - t.dts), -1 * ie) }, 0); if (E < 0) { ee.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + re(E, !0) + " ms to overcome this issue"); for (var T = 0; T < h.length; T++)h[T].dts += E } var b = h[0], S = Math.max(b.dts, 0), _ = Math.max(b.pts, 0), R = S - m; r && R && (1 < R ? ee.logger.log("AVC: " + re(R, !0) + " ms hole between fragments detected,filling it") : R < -1 && ee.logger.log("AVC: " + re(-R, !0) + " ms overlapping between fragments detected"), S = m, h[0].dts = S, _ = Math.max(_ - R, m), h[0].pts = _, ee.logger.log("Video: PTS/DTS adjusted: " + re(_, !0) + "/" + re(S, !0) + ", delta: " + re(R, !0) + " ms")), b = h[h.length - 1], u = Math.max(b.dts, 0), l = Math.max(b.pts, 0, u), y && (n = Math.round((u - S) / (h.length - 1))); for (var A = 0, k = 0, w = 0; w < g; w++) { for (var L = h[w], D = L.units, O = D.length, C = 0, I = 0; I < O; I++)C += D[I].data.length; k += C, A += O, L.length = C, L.dts = y ? S + w * n : Math.max(L.dts, S), L.pts = Math.max(L.pts, L.dts) } var x = k + 4 * A + 8; try { s = new Uint8Array(x) } catch (e) { return void this.observer.trigger(J.default.ERROR, { type: Z.ErrorTypes.MUX_ERROR, details: Z.ErrorDetails.REMUX_ALLOC_ERROR, fatal: !1, bytes: x, reason: "fail allocating video mdat " + x }) } var P = new DataView(s.buffer); P.setUint32(0, x), s.set(te.types.mdat, 4); for (var F = 0; F < g; F++) { for (var M, N, U, B, G = h[F], j = G.units, K = 0, H = void 0, V = 0, Y = j.length; V < Y; V++) { var W = j[V], q = W.data, z = W.data.byteLength; P.setUint32(d, z), d += 4, s.set(q, d), d += z, K += 4 + z } H = y ? Math.max(0, n * Math.round((G.pts - G.dts) / n)) : (F < g - 1 ? n = h[F + 1].dts - G.dts : (M = this.config, N = G.dts - h[0 < F ? F - 1 : F].dts, M.stretchShortVideoTrack ? (U = M.maxBufferHole, Math.floor(U * c) < (B = (i ? _ + i * c : this.nextAudioPts) - G.pts) ? ((n = B - N) < 0 && (n = N), ee.logger.log("It is approximately " + re(B, !1) + " ms to the next segment; using duration " + re(n, !1) + " ms for the last video frame.")) : n = N) : n = N), Math.round(G.pts - G.dts)), f.push({ size: K, duration: n, cts: H, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: G.key ? 2 : 1, isNonSync: G.key ? 0 : 1 } }) } this.nextAvcDts = u + n; var X, Q = e.dropped; e.nbNalu = 0, e.dropped = 0, f.length && -1 < navigator.userAgent.toLowerCase().indexOf("chrome") && ((X = f[0].flags).dependsOn = 2, X.isNonSync = 0), e.samples = f, o = te.moof(e.sequenceNumber++, S, e), e.samples = []; var $ = { data1: o, data2: s, startPTS: _ / c, endPTS: (l + n) / c, startDTS: S / c, endDTS: this.nextAvcDts / c, type: "video", hasAudio: !1, hasVideo: !0, nb: f.length, dropped: Q }; return this.observer.trigger(J.default.FRAG_PARSING_DATA, $), $ } }, t.remuxAudio = function (e, t, r, i) { var a, n, s, o, l, u = e.inputTimeScale, d = e.timescale, c = u / d, h = (e.isAAC ? 1024 : 1152) * c, f = this._PTSNormalize, g = this._initPTS, p = !e.isAAC && this.typeSupported.mpeg, v = p ? 0 : 8, m = e.samples, y = [], E = this.nextAudioPts; if (r |= m.length && E && (i && Math.abs(t - E / u) < .1 || Math.abs(m[0].pts - E - g) < 20 * h), m.forEach(function (e) { e.pts = e.dts = f(e.pts - g, t * u) }), 0 !== (m = m.filter(function (e) { return 0 <= e.pts })).length) { if (r || (E = i ? t * u : m[0].pts), e.isAAC) for (var T = this.config.maxAudioFramesDrift, b = 0, S = E; b < m.length;) { var _ = m[b], R = _.pts - S; if (R <= -T * h) ee.logger.warn("Dropping 1 audio frame @ " + re(S, !0) + " ms due to " + re(R, !0) + " ms overlap."), m.splice(b, 1); else if (T * h <= R && R < Y && S) { var A = Math.round(R / h); ee.logger.warn("Injecting " + A + " audio frames @ " + re(S, !0) + " ms due to " + re(S, !0) + " ms gap."); for (var k = 0; k < A; k++) { var w, L = Math.max(S, 0); (w = V.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (ee.logger.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), w = _.unit.subarray()), m.splice(b, 0, { unit: w, pts: L, dts: L }), S += h, b++ } _.pts = _.dts = S, S += h, b++ } else Math.abs(R), _.pts = _.dts = S, S += h, b++ } for (var D = m.length, O = 0; D--;)O += m[D].unit.byteLength; for (var C = 0, I = m.length; C < I; C++) { var x = m[C], P = x.unit, F = x.pts; if (void 0 !== l) a.duration = Math.round((F - l) / c); else { var M = F - E, N = 0; if (r && e.isAAC && M) { if (0 < M && M < Y) N = Math.round((F - E) / h), ee.logger.log(re(M, !0) + " ms hole between AAC samples detected,filling it"), 0 < N && (O += N * (w = (w = V.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || P.subarray()).length); else if (M < -12) { ee.logger.log("drop overlapping AAC sample, expected/parsed/delta: " + re(E, !0) + " ms / " + re(F, !0) + " ms / " + re(-M, !0) + " ms"), O -= P.byteLength; continue } F = E } if (o = F, !(0 < O)) return; O += v; try { n = new Uint8Array(O) } catch (e) { return void this.observer.trigger(J.default.ERROR, { type: Z.ErrorTypes.MUX_ERROR, details: Z.ErrorDetails.REMUX_ALLOC_ERROR, fatal: !1, bytes: O, reason: "fail allocating audio mdat " + O }) } p || (new DataView(n.buffer).setUint32(0, O), n.set(te.types.mdat, 4)); for (var U = 0; U < N; U++)(w = V.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (ee.logger.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), w = P.subarray()), n.set(w, v), v += w.byteLength, a = { size: w.byteLength, cts: 0, duration: 1024, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1 } }, y.push(a) } n.set(P, v); var B = P.byteLength; v += B, a = { size: B, cts: 0, duration: 0, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1 } }, y.push(a), l = F } var G = 0; if (2 <= (D = y.length) && (G = y[D - 2].duration, a.duration = G), D) { this.nextAudioPts = E = l + c * G, e.samples = y, s = p ? new Uint8Array : te.moof(e.sequenceNumber++, o / c, e), e.samples = []; var j = o / u, K = E / u, H = { data1: s, data2: n, startPTS: j, endPTS: K, startDTS: j, endDTS: K, type: "audio", hasAudio: !0, hasVideo: !1, nb: D }; return this.observer.trigger(J.default.FRAG_PARSING_DATA, H), H } return null } }, t.remuxEmptyAudio = function (e, t, r, i) { var a = e.inputTimeScale, n = a / (e.samplerate ? e.samplerate : a), s = this.nextAudioPts, o = (void 0 !== s ? s : i.startDTS * a) + this._initDTS, l = i.endDTS * a + this._initDTS, u = 1024 * n, d = Math.ceil((l - o) / u), c = V.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (ee.logger.warn("remux empty Audio"), c) { for (var h = [], f = 0; f < d; f++) { var g = o + f * u; h.push({ unit: c, pts: g, dts: g }) } e.samples = h, this.remuxAudio(e, t, r) } else ee.logger.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!") }, t.remuxID3 = function (e) { var t, r = e.samples.length, i = e.inputTimeScale, a = this._initPTS, n = this._initDTS; if (r) { for (var s = 0; s < r; s++)(t = e.samples[s]).pts = (t.pts - a) / i, t.dts = (t.dts - n) / i; this.observer.trigger(J.default.FRAG_PARSING_METADATA, { samples: e.samples }) } e.samples = [] }, t.remuxText = function (e) { e.samples.sort(function (e, t) { return e.pts - t.pts }); var t, r = e.samples.length, i = e.inputTimeScale, a = this._initPTS; if (r) { for (var n = 0; n < r; n++)(t = e.samples[n]).pts = (t.pts - a) / i; this.observer.trigger(J.default.FRAG_PARSING_USERDATA, { samples: e.samples }) } e.samples = [] }, t._PTSNormalize = function (e, t) { var r; if (void 0 === t) return e; for (r = t < e ? -8589934592 : 8589934592; 4294967296 < Math.abs(e - t);)e += r; return e }, e }(), O = function () { function e(e) { this.observer = e } var t = e.prototype; return t.destroy = function () { }, t.resetTimeStamp = function () { }, t.resetInitSegment = function () { }, t.remux = function (e, t, r, i, a, n, s, o) { var l = this.observer, u = ""; e && (u += "audio"), t && (u += "video"), l.trigger(J.default.FRAG_PARSING_DATA, { data1: o, startPTS: a, startDTS: a, type: u, hasAudio: !!e, hasVideo: !!t, nb: 1, dropped: 0 }), l.trigger(J.default.FRAG_PARSED) }, e }(), h = Object(i.getSelfScope)(); try { S = h.performance.now.bind(h.performance) } catch (e) { ee.logger.debug("Unable to use Performance API on this environment"), S = h.Date.now } var f = function () { function e(e, t, r, i) { this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i } var t = e.prototype; return t.destroy = function () { var e = this.demuxer; e && e.destroy() }, t.push = function (e, r, i, a, n, s, o, l, u, d, c, h) { var t, f, g = this; 0 < e.byteLength && null != r && null != r.key && "AES-128" === r.method ? (null == (t = this.decrypter) && (t = this.decrypter = new p.default(this.observer, this.config)), f = S(), t.decrypt(e, r.key.buffer, r.iv.buffer, function (e) { var t = S(); g.observer.trigger(J.default.FRAG_DECRYPTED, { stats: { tstart: f, tdecrypt: t } }), g.pushDecrypted(new Uint8Array(e), r, new Uint8Array(i), a, n, s, o, l, u, d, c, h) })) : this.pushDecrypted(new Uint8Array(e), r, new Uint8Array(i), a, n, s, o, l, u, d, c, h) }, t.pushDecrypted = function (e, t, r, i, a, n, s, o, l, u, d, c) { if (!(b = this.demuxer) || (s || o) && !this.probe(e)) { for (var h = this.observer, f = this.typeSupported, g = this.config, p = [{ demux: A, remux: D }, { demux: R.default, remux: O }, { demux: _, remux: D }, { demux: k, remux: D }], v = 0, m = p.length; v < m; v++) { var y = p[v], E = y.demux.probe; if (E(e)) { var T = this.remuxer = new y.remux(h, g, f, this.vendor), b = new y.demux(h, T, g, f); this.probe = E; break } } if (!b) return void h.trigger(J.default.ERROR, { type: Z.ErrorTypes.MEDIA_ERROR, details: Z.ErrorDetails.FRAG_PARSING_ERROR, fatal: !0, reason: "no demux matching with content found" }); this.demuxer = b } var S = this.remuxer; (s || o) && (b.resetInitSegment(r, i, a, u), S.resetInitSegment()), s && (b.resetTimeStamp(c), S.resetTimeStamp(c)), "function" == typeof b.setDecryptData && b.setDecryptData(t), b.append(e, n, l, d) }, e }(); t.default = f }, "./src/demux/demuxer-worker.js": function (e, t, r) { "use strict"; r.r(t); var s = r("./src/demux/demuxer-inline.js"), o = r("./src/events.js"), l = r("./src/utils/logger.js"), u = r("./node_modules/eventemitter3/index.js"); t.default = function (a) { var n = new u.EventEmitter; n.trigger = function (e) { for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; n.emit.apply(n, [e, e].concat(r)) }, n.off = function (e) { for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; n.removeListener.apply(n, [e].concat(r)) }; function i(e, t) { a.postMessage({ event: e, data: t }) } a.addEventListener("message", function (e) { var t = e.data; switch (t.cmd) { case "init": var r = JSON.parse(t.config); a.demuxer = new s.default(n, t.typeSupported, r, t.vendor), Object(l.enableLogs)(r.debug), i("init", null); break; case "demux": a.demuxer.push(t.data, t.decryptdata, t.initSegment, t.audioCodec, t.videoCodec, t.timeOffset, t.discontinuity, t.trackSwitch, t.contiguous, t.duration, t.accurateTimeOffset, t.defaultInitPTS) } }), n.on(o.default.FRAG_DECRYPTED, i), n.on(o.default.FRAG_PARSING_INIT_SEGMENT, i), n.on(o.default.FRAG_PARSED, i), n.on(o.default.ERROR, i), n.on(o.default.FRAG_PARSING_METADATA, i), n.on(o.default.FRAG_PARSING_USERDATA, i), n.on(o.default.INIT_PTS_FOUND, i), n.on(o.default.FRAG_PARSING_DATA, function (e, t) { var r = [], i = { event: e, data: t }; t.data1 && (i.data1 = t.data1.buffer, r.push(t.data1.buffer), delete t.data1), t.data2 && (i.data2 = t.data2.buffer, r.push(t.data2.buffer), delete t.data2), a.postMessage(i, r) }) } }, "./src/demux/id3.js": function (e, t, r) { "use strict"; r.r(t), r.d(t, "utf8ArrayToStr", function () { return a }); var c, h = r("./src/utils/get-self-scope.js"), i = function () { function o() { } return o.isHeader = function (e, t) { return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128 }, o.isFooter = function (e, t) { return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128 }, o.getID3Data = function (e, t) { for (var r = t, i = 0; o.isHeader(e, t);) { i += 10, i += o._readSize(e, t + 6), o.isFooter(e, t + 10) && (i += 10), t += i } if (0 < i) return e.subarray(r, r + i) }, o._readSize = function (e, t) { var r = (127 & e[t]) << 21; return r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3] }, o.getTimeStamp = function (e) { for (var t = o.getID3Frames(e), r = 0; r < t.length; r++) { var i = t[r]; if (o.isTimeStampFrame(i)) return o._readTimeStamp(i) } }, o.isTimeStampFrame = function (e) { return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info }, o._getFrameData = function (e) { var t = String.fromCharCode(e[0], e[1], e[2], e[3]), r = o._readSize(e, 4); return { type: t, size: r, data: e.subarray(10, 10 + r) } }, o.getID3Frames = function (e) { for (var t = 0, r = []; o.isHeader(e, t);) { for (var i = o._readSize(e, t + 6), a = (t += 10) + i; t + 8 < a;) { var n = o._getFrameData(e.subarray(t)), s = o._decodeFrame(n); s && r.push(s), t += n.size + 10 } o.isFooter(e, t) && (t += 10) } return r }, o._decodeFrame = function (e) { return "PRIV" === e.type ? o._decodePrivFrame(e) : "T" === e.type[0] ? o._decodeTextFrame(e) : "W" === e.type[0] ? o._decodeURLFrame(e) : void 0 }, o._readTimeStamp = function (e) { if (8 === e.data.byteLength) { var t = new Uint8Array(e.data), r = 1 & t[3], i = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7]; return i /= 45, r && (i += 47721858.84), Math.round(i) } }, o._decodePrivFrame = function (e) { if (!(e.size < 2)) { var t = o._utf8ArrayToStr(e.data, !0), r = new Uint8Array(e.data.subarray(t.length + 1)); return { key: e.type, info: t, data: r.buffer } } }, o._decodeTextFrame = function (e) { if (!(e.size < 2)) { if ("TXXX" === e.type) { var t = 1, r = o._utf8ArrayToStr(e.data.subarray(1), !0); t += r.length + 1; var i = o._utf8ArrayToStr(e.data.subarray(t)); return { key: e.type, info: r, data: i } } var a = o._utf8ArrayToStr(e.data.subarray(1)); return { key: e.type, data: a } } }, o._decodeURLFrame = function (e) { if ("WXXX" === e.type) { if (e.size < 2) return; var t = 1, r = o._utf8ArrayToStr(e.data.subarray(1)); t += r.length + 1; var i = o._utf8ArrayToStr(e.data.subarray(t)); return { key: e.type, info: r, data: i } } var a = o._utf8ArrayToStr(e.data); return { key: e.type, data: a } }, o._utf8ArrayToStr = function (e, t) { void 0 === t && (t = !1); var r = function () { var e = Object(h.getSelfScope)(); c || void 0 === e.TextDecoder || (c = new e.TextDecoder("utf-8")); return c }(); if (r) { var i = r.decode(e); if (t) { var a = i.indexOf("\0"); return -1 !== a ? i.substring(0, a) : i } return i.replace(/\0/g, "") } for (var n, s, o, l = e.length, u = "", d = 0; d < l;) { if (0 === (n = e[d++]) && t) return u; if (0 !== n && 3 !== n) switch (n >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: u += String.fromCharCode(n); break; case 12: case 13: s = e[d++], u += String.fromCharCode((31 & n) << 6 | 63 & s); break; case 14: s = e[d++], o = e[d++], u += String.fromCharCode((15 & n) << 12 | (63 & s) << 6 | (63 & o) << 0) } } return u }, o }(); var a = i._utf8ArrayToStr; t.default = i }, "./src/demux/mp4demuxer.js": function (e, t, r) { "use strict"; r.r(t); var c = r("./src/utils/logger.js"), l = r("./src/events.js"), o = Math.pow(2, 32) - 1, i = function () { function p(e, t) { this.observer = e, this.remuxer = t } var e = p.prototype; return e.resetTimeStamp = function (e) { this.initPTS = e }, e.resetInitSegment = function (e, t, r, i) { var a, n; e && e.byteLength ? (null == t && (t = "mp4a.40.5"), null == r && (r = "avc1.42e01e"), n = {}, (a = this.initData = p.parseInitSegment(e)).audio && a.video ? n.audiovideo = { container: "video/mp4", codec: t + "," + r, initSegment: i ? e : null } : (a.audio && (n.audio = { container: "audio/mp4", codec: t, initSegment: i ? e : null }), a.video && (n.video = { container: "video/mp4", codec: r, initSegment: i ? e : null })), this.observer.trigger(l.default.FRAG_PARSING_INIT_SEGMENT, { tracks: n })) : (t && (this.audioCodec = t), r && (this.videoCodec = r)) }, p.probe = function (e) { return 0 < p.findBox({ data: e, start: 0, end: Math.min(e.length, 16384) }, ["moof"]).length }, p.bin2str = function (e) { return String.fromCharCode.apply(null, e) }, p.readUint16 = function (e, t) { e.data && (t += e.start, e = e.data); var r = e[t] << 8 | e[t + 1]; return r < 0 ? 65536 + r : r }, p.readUint32 = function (e, t) { e.data && (t += e.start, e = e.data); var r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]; return r < 0 ? 4294967296 + r : r }, p.writeUint32 = function (e, t, r) { e.data && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r }, p.findBox = function (e, t) { var r, i, a, n, s, o, l = []; if (e.data ? (s = e.start, a = e.end, e = e.data) : (s = 0, a = e.byteLength), !t.length) return null; for (r = s; r < a;)o = 1 < (i = p.readUint32(e, r)) ? r + i : a, p.bin2str(e.subarray(r + 4, r + 8)) === t[0] && (1 === t.length ? l.push({ data: e, start: r + 8, end: o }) : (n = p.findBox({ data: e, start: r + 8, end: o }, t.slice(1))).length && (l = l.concat(n))), r = o; return l }, p.parseSegmentIndex = function (e) { var t, r = p.findBox(e, ["moov"])[0], i = r ? r.end : null, a = 0, n = p.findBox(e, ["sidx"]); if (!n || !n[0]) return null; t = []; var s = (n = n[0]).data[0], o = p.readUint32(n, a = 0 === s ? 8 : 16); a += 4; a += 0 === s ? 8 : 16, a += 2; var l = n.end + 0, u = p.readUint16(n, a); a += 2; for (var d = 0; d < u; d++) { var c = a, h = p.readUint32(n, c), f = 2147483647 & h; if (1 == (2147483648 & h) >>> 31) return; var g = p.readUint32(n, c += 4); c += 4, t.push({ referenceSize: f, subsegmentDuration: g, info: { duration: g / o, start: l, end: l + f - 1 } }), l += f, a = c += 4 } return { earliestPresentationTime: 0, timescale: o, version: s, referencesCount: u, references: t, moovEndOffset: i } }, p.parseInitSegment = function (e) { var d = []; return p.findBox(e, ["moov", "trak"]).forEach(function (e) { var t, r, i, a, n, s, o, l, u = p.findBox(e, ["tkhd"])[0]; u && (t = u.data[u.start], r = p.readUint32(u, 0 === t ? 12 : 20), (i = p.findBox(e, ["mdia", "mdhd"])[0]) && (t = i.data[i.start], a = p.readUint32(i, 0 === t ? 12 : 20), !(n = p.findBox(e, ["mdia", "hdlr"])[0]) || (s = { soun: "audio", vide: "video" }[p.bin2str(n.data.subarray(n.start + 8, n.start + 12))]) && ((o = p.findBox(e, ["mdia", "minf", "stbl", "stsd"])).length && (o = o[0], l = p.bin2str(o.data.subarray(o.start + 12, o.start + 16)), c.logger.log("MP4Demuxer:" + s + ":" + l + " found")), d[r] = { timescale: a, type: s }, d[s] = { timescale: a, id: r }))) }), d }, p.getStartDTS = function (a, e) { var t = p.findBox(e, ["moof", "traf"]), r = [].concat.apply([], t.map(function (i) { return p.findBox(i, ["tfhd"]).map(function (e) { var t = p.readUint32(e, 4), r = a[t].timescale || 9e4; return p.findBox(i, ["tfdt"]).map(function (e) { var t = e.data[e.start], r = p.readUint32(e, 4); return 1 === t && (r *= Math.pow(2, 32), r += p.readUint32(e, 8)), r })[0] / r }) })), i = Math.min.apply(null, r); return isFinite(i) ? i : 0 }, p.offsetStartDTS = function (i, e, s) { p.findBox(e, ["moof", "traf"]).map(function (r) { return p.findBox(r, ["tfhd"]).map(function (e) { var t = p.readUint32(e, 4), n = i[t].timescale || 9e4; p.findBox(r, ["tfdt"]).map(function (e) { var t, r, i = e.data[e.start], a = p.readUint32(e, 4); 0 === i ? p.writeUint32(e, 4, a - s * n) : (a *= Math.pow(2, 32), a += p.readUint32(e, 8), a -= s * n, a = Math.max(a, 0), t = Math.floor(a / (1 + o)), r = Math.floor(a % (1 + o)), p.writeUint32(e, 4, t), p.writeUint32(e, 8, r)) }) }) }) }, e.append = function (e, t, r, i) { var a = this.initData; a || (this.resetInitSegment(e, this.audioCodec, this.videoCodec, !1), a = this.initData); var n, s, o = this.initPTS; void 0 === o && (s = p.getStartDTS(a, e), this.initPTS = o = s - t, this.observer.trigger(l.default.INIT_PTS_FOUND, { initPTS: o })), p.offsetStartDTS(a, e, o), n = p.getStartDTS(a, e), this.remuxer.remux(a.audio, a.video, null, null, n, r, i, e) }, e.destroy = function () { }, p }(); t.default = i }, "./src/errors.ts": function (e, t, r) { "use strict"; var i, a, n, s; r.r(t), r.d(t, "ErrorTypes", function () { return i }), r.d(t, "ErrorDetails", function () { return n }), (a = i = i || {}).NETWORK_ERROR = "networkError", a.MEDIA_ERROR = "mediaError", a.KEY_SYSTEM_ERROR = "keySystemError", a.MUX_ERROR = "muxError", a.OTHER_ERROR = "otherError", (s = n = n || {}).KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", s.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", s.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", s.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", s.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", s.MANIFEST_LOAD_ERROR = "manifestLoadError", s.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", s.MANIFEST_PARSING_ERROR = "manifestParsingError", s.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", s.LEVEL_LOAD_ERROR = "levelLoadError", s.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", s.LEVEL_SWITCH_ERROR = "levelSwitchError", s.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", s.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", s.FRAG_LOAD_ERROR = "fragLoadError", s.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", s.FRAG_DECRYPT_ERROR = "fragDecryptError", s.FRAG_PARSING_ERROR = "fragParsingError", s.REMUX_ALLOC_ERROR = "remuxAllocError", s.KEY_LOAD_ERROR = "keyLoadError", s.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", s.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", s.BUFFER_APPEND_ERROR = "bufferAppendError", s.BUFFER_APPENDING_ERROR = "bufferAppendingError", s.BUFFER_STALLED_ERROR = "bufferStalledError", s.BUFFER_FULL_ERROR = "bufferFullError", s.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", s.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", s.INTERNAL_EXCEPTION = "internalException" }, "./src/events.js": function (e, t, r) { "use strict"; r.r(t); t.default = { MEDIA_ATTACHING: "hlsMediaAttaching", MEDIA_ATTACHED: "hlsMediaAttached", MEDIA_DETACHING: "hlsMediaDetaching", MEDIA_DETACHED: "hlsMediaDetached", BUFFER_RESET: "hlsBufferReset", BUFFER_CODECS: "hlsBufferCodecs", BUFFER_CREATED: "hlsBufferCreated", BUFFER_APPENDING: "hlsBufferAppending", BUFFER_APPENDED: "hlsBufferAppended", BUFFER_EOS: "hlsBufferEos", BUFFER_FLUSHING: "hlsBufferFlushing", BUFFER_FLUSHED: "hlsBufferFlushed", MANIFEST_LOADING: "hlsManifestLoading", MANIFEST_LOADED: "hlsManifestLoaded", MANIFEST_PARSED: "hlsManifestParsed", LEVEL_SWITCHING: "hlsLevelSwitching", LEVEL_SWITCHED: "hlsLevelSwitched", LEVEL_LOADING: "hlsLevelLoading", LEVEL_LOADED: "hlsLevelLoaded", LEVEL_UPDATED: "hlsLevelUpdated", LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated", AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated", AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching", AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched", AUDIO_TRACK_LOADING: "hlsAudioTrackLoading", AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded", SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated", SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch", SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading", SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded", SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed", INIT_PTS_FOUND: "hlsInitPtsFound", FRAG_LOADING: "hlsFragLoading", FRAG_LOAD_PROGRESS: "hlsFragLoadProgress", FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted", FRAG_LOADED: "hlsFragLoaded", FRAG_DECRYPTED: "hlsFragDecrypted", FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment", FRAG_PARSING_USERDATA: "hlsFragParsingUserdata", FRAG_PARSING_METADATA: "hlsFragParsingMetadata", FRAG_PARSING_DATA: "hlsFragParsingData", FRAG_PARSED: "hlsFragParsed", FRAG_BUFFERED: "hlsFragBuffered", FRAG_CHANGED: "hlsFragChanged", FPS_DROP: "hlsFpsDrop", FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping", ERROR: "hlsError", DESTROYING: "hlsDestroying", KEY_LOADING: "hlsKeyLoading", KEY_LOADED: "hlsKeyLoaded", STREAM_STATE_TRANSITION: "hlsStreamStateTransition", LIVE_BACK_BUFFER_REACHED: "hlsLiveBackBufferReached" } }, "./src/hls.ts": function (e, t, r) { "use strict"; r.r(t); var i = {}; r.r(i), r.d(i, "newCue", function () { return mt }); var v, a, l, n, s = r("./node_modules/url-toolkit/src/url-toolkit.js"), h = r("./src/errors.ts"), F = r("./src/polyfills/number-isFinite.js"), M = r("./src/events.js"), N = r("./src/utils/logger.js"), o = { hlsEventGeneric: !0, hlsHandlerDestroying: !0, hlsHandlerDestroyed: !0 }, u = function () { function e(e) { this.hls = void 0, this.handledEvents = void 0, this.useGenericHandler = void 0, this.hls = e, this.onEvent = this.onEvent.bind(this); for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; this.handledEvents = r, this.useGenericHandler = !0, this.registerListeners() } var t = e.prototype; return t.destroy = function () { this.onHandlerDestroying(), this.unregisterListeners(), this.onHandlerDestroyed() }, t.onHandlerDestroying = function () { }, t.onHandlerDestroyed = function () { }, t.isEventHandler = function () { return "object" == typeof this.handledEvents && this.handledEvents.length && "function" == typeof this.onEvent }, t.registerListeners = function () { this.isEventHandler() && this.handledEvents.forEach(function (e) { if (o[e]) throw new Error("Forbidden event-name: " + e); this.hls.on(e, this.onEvent) }, this) }, t.unregisterListeners = function () { this.isEventHandler() && this.handledEvents.forEach(function (e) { this.hls.off(e, this.onEvent) }, this) }, t.onEvent = function (e, t) { this.onEventGeneric(e, t) }, t.onEventGeneric = function (t, e) { try { (function (e, t) { var r = "on" + e.replace("hls", ""); if ("function" != typeof this[r]) throw new Error("Event " + e + " has no generic handler in this " + this.constructor.name + " class (tried " + r + ")"); return this[r].bind(this, t) }).call(this, t, e).call() } catch (e) { N.logger.error("An internal error happened while handling event " + t + '. Error message: "' + e.message + '". Here is a stacktrace:', e), this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.OTHER_ERROR, details: h.ErrorDetails.INTERNAL_EXCEPTION, fatal: !1, event: t, err: e }) } }, e }(); (a = v = v || {}).MANIFEST = "manifest", a.LEVEL = "level", a.AUDIO_TRACK = "audioTrack", a.SUBTITLE_TRACK = "subtitleTrack", (n = l = l || {}).MAIN = "main", n.AUDIO = "audio", n.SUBTITLE = "subtitle"; var d = r("./src/demux/mp4demuxer.js"); function c(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var f, g, w = function () { function e(e, t) { this._uri = null, this.baseuri = void 0, this.reluri = void 0, this.method = null, this.key = null, this.iv = null, this.baseuri = e, this.reluri = t } var t, r, i; return t = e, (r = [{ key: "uri", get: function () { return !this._uri && this.reluri && (this._uri = Object(s.buildAbsoluteURL)(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri } }]) && c(t.prototype, r), i && c(t, i), e }(); function p(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } (g = f = f || {}).AUDIO = "audio", g.VIDEO = "video"; var L = function () { function e() { var e; this._url = null, this._byteRange = null, this._decryptdata = null, this._elementaryStreams = ((e = {})[f.AUDIO] = !1, e[f.VIDEO] = !1, e), this.deltaPTS = 0, this.rawProgramDateTime = null, this.programDateTime = null, this.title = null, this.tagList = [], this.cc = void 0, this.type = void 0, this.relurl = void 0, this.baseurl = void 0, this.duration = void 0, this.start = void 0, this.sn = 0, this.urlId = 0, this.level = 0, this.levelkey = void 0, this.loader = void 0 } var t, r, i, a = e.prototype; return a.setByteRange = function (e, t) { var r = e.split("@", 2), i = []; 1 === r.length ? i[0] = t ? t.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i }, a.addElementaryStream = function (e) { this._elementaryStreams[e] = !0 }, a.hasElementaryStream = function (e) { return !0 === this._elementaryStreams[e] }, a.createInitializationVector = function (e) { for (var t = new Uint8Array(16), r = 12; r < 16; r++)t[r] = e >> 8 * (15 - r) & 255; return t }, a.setDecryptDataFromLevelKey = function (e, t) { var r = e; return e && e.method && e.uri && !e.iv && ((r = new w(e.baseuri, e.reluri)).method = e.method, r.iv = this.createInitializationVector(t)), r }, t = e, (r = [{ key: "url", get: function () { return !this._url && this.relurl && (this._url = Object(s.buildAbsoluteURL)(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url }, set: function (e) { this._url = e } }, { key: "byteRange", get: function () { return this._byteRange ? this._byteRange : [] } }, { key: "byteRangeStartOffset", get: function () { return this.byteRange[0] } }, { key: "byteRangeEndOffset", get: function () { return this.byteRange[1] } }, { key: "decryptdata", get: function () { return this.levelkey || this._decryptdata ? (!this._decryptdata && this.levelkey && ("number" != typeof (e = this.sn) && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && N.logger.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), e = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e)), this._decryptdata) : null; var e } }, { key: "endProgramDateTime", get: function () { if (null === this.programDateTime) return null; if (!Object(F.isFiniteNumber)(this.programDateTime)) return null; var e = Object(F.isFiniteNumber)(this.duration) ? this.duration : 0; return this.programDateTime + 1e3 * e } }, { key: "encrypted", get: function () { return !(!this.decryptdata || null === this.decryptdata.uri || null !== this.decryptdata.key) } }]) && p(t.prototype, r), i && p(t, i), e }(); function m(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var D = function () { function e(e) { this.endCC = 0, this.endSN = 0, this.fragments = [], this.initSegment = null, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = e, this.version = null } var t, r, i; return t = e, (r = [{ key: "hasProgramDateTime", get: function () { return !(!this.fragments[0] || !Object(F.isFiniteNumber)(this.fragments[0].programDateTime)) } }]) && m(t.prototype, r), i && m(t, i), e }(), y = /^(\d+)x(\d+)$/, E = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, O = function () { function r(e) { for (var t in "string" == typeof e && (e = r.parseAttrList(e)), e) e.hasOwnProperty(t) && (this[t] = e[t]) } var e = r.prototype; return e.decimalInteger = function (e) { var t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t }, e.hexadecimalInteger = function (e) { if (this[e]) { for (var t = (1 & (t = (this[e] || "0x").slice(2)).length ? "0" : "") + t, r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++)r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16); return r } return null }, e.hexadecimalIntegerAsNumber = function (e) { var t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t }, e.decimalFloatingPoint = function (e) { return parseFloat(this[e]) }, e.enumeratedString = function (e) { return this[e] }, e.decimalResolution = function (e) { var t = y.exec(this[e]); if (null !== t) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) } }, r.parseAttrList = function (e) { var t, r = {}; for (E.lastIndex = 0; null !== (t = E.exec(e));) { var i = t[2]; 0 === i.indexOf('"') && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)), r[t[1]] = i } return r }, r }(), T = { audio: { a3ds: !0, "ac-3": !0, "ac-4": !0, alac: !0, alaw: !0, dra1: !0, "dts+": !0, "dts-": !0, dtsc: !0, dtse: !0, dtsh: !0, "ec-3": !0, enca: !0, g719: !0, g726: !0, m4ae: !0, mha1: !0, mha2: !0, mhm1: !0, mhm2: !0, mlpa: !0, mp4a: !0, "raw ": !0, Opus: !0, samr: !0, sawb: !0, sawp: !0, sevc: !0, sqcp: !0, ssmv: !0, twos: !0, ulaw: !0 }, video: { avc1: !0, avc2: !0, avc3: !0, avc4: !0, avcp: !0, drac: !0, dvav: !0, dvhe: !0, encv: !0, hev1: !0, hvc1: !0, mjp2: !0, mp4v: !0, mvc1: !0, mvc2: !0, mvc3: !0, mvc4: !0, resv: !0, rv60: !0, s263: !0, svc1: !0, svc2: !0, "vc-1": !0, vp08: !0, vp09: !0 } }; function b(e, t) { return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"') } var S = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g, _ = /#EXT-X-MEDIA:(.*)/g, C = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /|(?!#)([\S+ ?]+)/.source, /|#EXT-X-BYTERANGE:*(.+)/.source, /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /|#.*/.source].join(""), "g"), I = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/, x = /\.(mp4|m4s|m4v|m4a)$/i, R = function () { function d() { } return d.findGroup = function (e, t) { for (var r = 0; r < e.length; r++) { var i = e[r]; if (i.id === t) return i } }, d.convertAVC1ToAVCOTI = function (e) { var t, r = e.split("."); return 2 < r.length ? (t = r.shift() + ".", t += parseInt(r.shift()).toString(16), t += ("000" + parseInt(r.shift()).toString(16)).substr(-4)) : t = e, t }, d.resolve = function (e, t) { return s.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) }, d.parseMasterPlaylist = function (e, t) { var r, i = []; function a(r, a) { ["video", "audio"].forEach(function (i) { var e, t = r.filter(function (e) { return t = e, !!(r = T[i]) && !0 === r[t.slice(0, 4)]; var t, r }); t.length && (e = t.filter(function (e) { return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0) }), a[i + "Codec"] = 0 < e.length ? e[0] : t[0], r = r.filter(function (e) { return -1 === t.indexOf(e) })) }), a.unknownCodecs = r } for (S.lastIndex = 0; null != (r = S.exec(e));) { var n = {}, s = n.attrs = new O(r[1]); n.url = d.resolve(r[2], t); var o = s.decimalResolution("RESOLUTION"); o && (n.width = o.width, n.height = o.height), n.bitrate = s.decimalInteger("AVERAGE-BANDWIDTH") || s.decimalInteger("BANDWIDTH"), n.name = s.NAME, a([].concat((s.CODECS || "").split(/[ ,]+/)), n), n.videoCodec && -1 !== n.videoCodec.indexOf("avc1") && (n.videoCodec = d.convertAVC1ToAVCOTI(n.videoCodec)), i.push(n) } return i }, d.parseMasterPlaylistMedia = function (e, t, r, i) { var a; void 0 === i && (i = []); var n = [], s = 0; for (_.lastIndex = 0; null !== (a = _.exec(e));) { var o, l, u = new O(a[1]); u.TYPE === r && (o = { id: s++, groupId: u["GROUP-ID"], name: u.NAME || u.LANGUAGE, type: r, default: "YES" === u.DEFAULT, autoselect: "YES" === u.AUTOSELECT, forced: "YES" === u.FORCED, lang: u.LANGUAGE }, u.URI && (o.url = d.resolve(u.URI, t)), i.length && (l = d.findGroup(i, o.groupId), o.audioCodec = l ? l.codec : i[0].codec), n.push(o)) } return n }, d.parseLevelPlaylist = function (e, t, r, i, a) { var n, s, o, l = 0, u = 0, d = new D(t), c = 0, h = null, f = new L, g = null; for (C.lastIndex = 0; null !== (n = C.exec(e));) { var p, v = n[1]; if (v) { f.duration = parseFloat(v); var m = (" " + n[2]).slice(1); f.title = m || null, f.tagList.push(m ? ["INF", v, m] : ["INF", v]) } else if (n[3]) { Object(F.isFiniteNumber)(f.duration) && (p = l++, f.type = i, f.start = u, o && (f.levelkey = o), f.sn = p, f.level = r, f.cc = c, f.urlId = a, f.baseurl = t, f.relurl = (" " + n[3]).slice(1), function (e, t) { e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : t && t.programDateTime && (e.programDateTime = t.endProgramDateTime); Object(F.isFiniteNumber)(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null) }(f, h), d.fragments.push(f), u += (h = f).duration, f = new L) } else if (n[4]) { var y = (" " + n[4]).slice(1); h ? f.setByteRange(y, h) : f.setByteRange(y) } else if (n[5]) f.rawProgramDateTime = (" " + n[5]).slice(1), f.tagList.push(["PROGRAM-DATE-TIME", f.rawProgramDateTime]), null === g && (g = d.fragments.length); else { if (!(n = n[0].match(I))) { N.logger.warn("No matches on slow regex match for level playlist!"); continue } for (s = 1; s < n.length && void 0 === n[s]; s++); var E = (" " + n[s + 1]).slice(1), T = (" " + n[s + 2]).slice(1); switch (n[s]) { case "#": f.tagList.push(T ? [E, T] : [E]); break; case "PLAYLIST-TYPE": d.type = E.toUpperCase(); break; case "MEDIA-SEQUENCE": l = d.startSN = parseInt(E); break; case "TARGETDURATION": d.targetduration = parseFloat(E); break; case "VERSION": d.version = parseInt(E); break; case "EXTM3U": break; case "ENDLIST": d.live = !1; break; case "DIS": c++, f.tagList.push(["DIS"]); break; case "DISCONTINUITY-SEQ": c = parseInt(E); break; case "KEY": var b = new O(E), S = b.enumeratedString("METHOD"), _ = b.URI, R = b.hexadecimalInteger("IV"); S && (o = new w(t, _), _ && 0 <= ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(S) && (o.method = S, o.key = null, o.iv = R)); break; case "START": var A = new O(E).decimalFloatingPoint("TIME-OFFSET"); Object(F.isFiniteNumber)(A) && (d.startTimeOffset = A); break; case "MAP": var k = new O(E); f.relurl = k.URI, k.BYTERANGE && f.setByteRange(k.BYTERANGE), f.baseurl = t, f.level = r, f.type = i, f.sn = "initSegment", d.initSegment = f, (f = new L).rawProgramDateTime = d.initSegment.rawProgramDateTime; break; default: N.logger.warn("line parsed but not handled: " + n) } } } return (f = h) && !f.relurl && (d.fragments.pop(), u -= f.duration), d.totalduration = u, d.averagetargetduration = u / d.fragments.length, d.endSN = l - 1, d.startCC = d.fragments[0] ? d.fragments[0].cc : 0, d.endCC = c, !d.initSegment && d.fragments.length && d.fragments.every(function (e) { return x.test(e.relurl) }) && (N.logger.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (f = new L).relurl = d.fragments[0].relurl, f.baseurl = t, f.level = r, f.type = i, f.sn = "initSegment", d.initSegment = f, d.needSidxRanges = !0), g && function (e, t) { for (var r = e[t], i = t - 1; 0 <= i; i--) { var a = e[i]; a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a } }(d.fragments, g), d }, d }(); var A = window.performance, k = function (r) { var e, t; function p(e) { var t = r.call(this, e, M.default.MANIFEST_LOADING, M.default.LEVEL_LOADING, M.default.AUDIO_TRACK_LOADING, M.default.SUBTITLE_TRACK_LOADING) || this; return t.loaders = {}, t } t = r, (e = p).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t, p.canHaveQualityLevels = function (e) { return e !== v.AUDIO_TRACK && e !== v.SUBTITLE_TRACK }, p.mapContextToLevelType = function (e) { switch (e.type) { case v.AUDIO_TRACK: return l.AUDIO; case v.SUBTITLE_TRACK: return l.SUBTITLE; default: return l.MAIN } }, p.getResponseUrl = function (e, t) { var r = e.url; return void 0 !== r && 0 !== r.indexOf("data:") || (r = t.url), r }; var i = p.prototype; return i.createInternalLoader = function (e) { var t = this.hls.config, r = t.pLoader, i = t.loader, a = new (r || i)(t); return e.loader = a, this.loaders[e.type] = a }, i.getInternalLoader = function (e) { return this.loaders[e.type] }, i.resetInternalLoader = function (e) { this.loaders[e] && delete this.loaders[e] }, i.destroyInternalLoaders = function () { for (var e in this.loaders) { var t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } }, i.destroy = function () { this.destroyInternalLoaders(), r.prototype.destroy.call(this) }, i.onManifestLoading = function (e) { this.load({ url: e.url, type: v.MANIFEST, level: 0, id: null, responseType: "text" }) }, i.onLevelLoading = function (e) { this.load({ url: e.url, type: v.LEVEL, level: e.level, id: e.id, responseType: "text" }) }, i.onAudioTrackLoading = function (e) { this.load({ url: e.url, type: v.AUDIO_TRACK, level: null, id: e.id, responseType: "text" }) }, i.onSubtitleTrackLoading = function (e) { this.load({ url: e.url, type: v.SUBTITLE_TRACK, level: null, id: e.id, responseType: "text" }) }, i.load = function (e) { var t = this.hls.config; N.logger.debug("Loading playlist of type " + e.type + ", level: " + e.level + ", id: " + e.id); var r, i, a, n, s = this.getInternalLoader(e); if (s) { var o = s.context; if (o && o.url === e.url) return N.logger.trace("playlist request ongoing"), !1; N.logger.warn("aborting previous loader for type: " + e.type), s.abort() } switch (e.type) { case v.MANIFEST: r = t.manifestLoadingMaxRetry, i = t.manifestLoadingTimeOut, a = t.manifestLoadingRetryDelay, n = t.manifestLoadingMaxRetryTimeout; break; case v.LEVEL: a = n = r = 0, i = t.levelLoadingTimeOut; break; default: r = t.levelLoadingMaxRetry, i = t.levelLoadingTimeOut, a = t.levelLoadingRetryDelay, n = t.levelLoadingMaxRetryTimeout }s = this.createInternalLoader(e); var l = { timeout: i, maxRetry: r, retryDelay: a, maxRetryDelay: n }, u = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }; return N.logger.debug("Calling internal loader delegate for URL: " + e.url), s.load(e, l, u), !0 }, i.loadsuccess = function (e, t, r, i) { if (void 0 === i && (i = null), r.isSidxRequest) return this._handleSidxRequest(e, r), void this._handlePlaylistLoaded(e, t, r, i); if (this.resetInternalLoader(r.type), "string" != typeof e.data) throw new Error('expected responseType of "text" for PlaylistLoader'); var a = e.data; t.tload = A.now(), 0 === a.indexOf("#EXTM3U") ? 0 < a.indexOf("#EXTINF:") || 0 < a.indexOf("#EXT-X-TARGETDURATION:") ? this._handleTrackOrLevelPlaylist(e, t, r, i) : this._handleMasterPlaylist(e, t, r, i) : this._handleManifestParsingError(e, r, "no EXTM3U delimiter", i) }, i.loaderror = function (e, t, r) { void 0 === r && (r = null), this._handleNetworkError(t, r, !1, e) }, i.loadtimeout = function (e, t, r) { void 0 === r && (r = null), this._handleNetworkError(t, r, !0) }, i._handleMasterPlaylist = function (e, t, r, i) { var a, n, s, o, l = this.hls, u = e.data, d = p.getResponseUrl(e, r), c = R.parseMasterPlaylist(u, d); c.length ? (a = c.map(function (e) { return { id: e.attrs.AUDIO, codec: e.audioCodec } }), n = R.parseMasterPlaylistMedia(u, d, "AUDIO", a), s = R.parseMasterPlaylistMedia(u, d, "SUBTITLES"), n.length && (o = !1, n.forEach(function (e) { e.url || (o = !0) }), !1 === o && c[0].audioCodec && !c[0].attrs.AUDIO && (N.logger.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), n.unshift({ type: "main", name: "main", default: !1, autoselect: !1, forced: !1, id: -1 }))), l.trigger(M.default.MANIFEST_LOADED, { levels: c, audioTracks: n, subtitles: s, url: d, stats: t, networkDetails: i })) : this._handleManifestParsingError(e, r, "no level found in manifest", i) }, i._handleTrackOrLevelPlaylist = function (e, t, r, i) { var a, n, s = this.hls, o = r.id, l = r.level, u = r.type, d = p.getResponseUrl(e, r), c = Object(F.isFiniteNumber)(o) ? o : 0, h = Object(F.isFiniteNumber)(l) ? l : c, f = p.mapContextToLevelType(r), g = R.parseLevelPlaylist(e.data, d, h, f, c); g.tload = t.tload, u === v.MANIFEST && (a = { url: d, details: g }, s.trigger(M.default.MANIFEST_LOADED, { levels: [a], audioTracks: [], url: d, stats: t, networkDetails: i })), t.tparsed = A.now(), g.needSidxRanges ? (n = g.initSegment.url, this.load({ url: n, isSidxRequest: !0, type: u, level: l, levelDetails: g, id: o, rangeStart: 0, rangeEnd: 2048, responseType: "arraybuffer" })) : (r.levelDetails = g, this._handlePlaylistLoaded(e, t, r, i)) }, i._handleSidxRequest = function (e, t) { if ("string" == typeof e.data) throw new Error("sidx request must be made with responseType of array buffer"); var r, a, i = d.default.parseSegmentIndex(new Uint8Array(e.data)); i && (r = i.references, a = t.levelDetails, r.forEach(function (e, t) { var r, i = e.info; !a || 0 === (r = a.fragments[t]).byteRange.length && r.setByteRange(String(1 + i.end - i.start) + "@" + String(i.start)) }), a && a.initSegment.setByteRange(String(i.moovEndOffset) + "@0")) }, i._handleManifestParsingError = function (e, t, r, i) { this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.NETWORK_ERROR, details: h.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: !0, url: e.url, reason: r, networkDetails: i }) }, i._handleNetworkError = function (e, t, r, i) { var a, n; void 0 === r && (r = !1), void 0 === i && (i = null), N.logger.info("A network error occured while loading a " + e.type + "-type playlist"); var s = this.getInternalLoader(e); switch (e.type) { case v.MANIFEST: a = r ? h.ErrorDetails.MANIFEST_LOAD_TIMEOUT : h.ErrorDetails.MANIFEST_LOAD_ERROR, n = !0; break; case v.LEVEL: a = r ? h.ErrorDetails.LEVEL_LOAD_TIMEOUT : h.ErrorDetails.LEVEL_LOAD_ERROR, n = !1; break; case v.AUDIO_TRACK: a = r ? h.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : h.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, n = !1; break; default: n = !1 }s && (s.abort(), this.resetInternalLoader(e.type)); var o = { type: h.ErrorTypes.NETWORK_ERROR, details: a, fatal: n, url: e.url, loader: s, context: e, networkDetails: t }; i && (o.response = i), this.hls.trigger(M.default.ERROR, o) }, i._handlePlaylistLoaded = function (e, t, r, i) { var a = r.type, n = r.level, s = r.id, o = r.levelDetails; if (o && o.targetduration) if (p.canHaveQualityLevels(r.type)) this.hls.trigger(M.default.LEVEL_LOADED, { details: o, level: n || 0, id: s || 0, stats: t, networkDetails: i }); else switch (a) { case v.AUDIO_TRACK: this.hls.trigger(M.default.AUDIO_TRACK_LOADED, { details: o, id: s, stats: t, networkDetails: i }); break; case v.SUBTITLE_TRACK: this.hls.trigger(M.default.SUBTITLE_TRACK_LOADED, { details: o, id: s, stats: t, networkDetails: i }) } else this._handleManifestParsingError(e, r, "invalid target duration", i) }, p }(u); var P = function (i) { var e, t; function r(e) { var t = i.call(this, e, M.default.FRAG_LOADING) || this; return t.loaders = {}, t } t = i, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a = r.prototype; return a.destroy = function () { var e = this.loaders; for (var t in e) { var r = e[t]; r && r.destroy() } this.loaders = {}, i.prototype.destroy.call(this) }, a.onFragLoading = function (e) { var t = e.frag, r = t.type, i = this.loaders, a = this.hls.config, n = a.fLoader, s = a.loader; t.loaded = 0; var o, l, u, d = i[r]; d && (N.logger.warn("abort previous fragment loader for type: " + r), d.abort()), d = i[r] = t.loader = new (a.fLoader ? n : s)(a), o = { url: t.url, frag: t, responseType: "arraybuffer", progressData: !1 }; var c = t.byteRangeStartOffset, h = t.byteRangeEndOffset; Object(F.isFiniteNumber)(c) && Object(F.isFiniteNumber)(h) && (o.rangeStart = c, o.rangeEnd = h), l = { timeout: a.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: a.fragLoadingMaxRetryTimeout }, u = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, d.load(o, l, u) }, a.loadsuccess = function (e, t, r, i) { void 0 === i && (i = null); var a = e.data, n = r.frag; n.loader = void 0, this.loaders[n.type] = void 0, this.hls.trigger(M.default.FRAG_LOADED, { payload: a, frag: n, stats: t, networkDetails: i }) }, a.loaderror = function (e, t, r) { void 0 === r && (r = null); var i = t.frag, a = i.loader; a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.NETWORK_ERROR, details: h.ErrorDetails.FRAG_LOAD_ERROR, fatal: !1, frag: t.frag, response: e, networkDetails: r }) }, a.loadtimeout = function (e, t, r) { void 0 === r && (r = null); var i = t.frag, a = i.loader; a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.NETWORK_ERROR, details: h.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: !1, frag: t.frag, networkDetails: r }) }, a.loadprogress = function (e, t, r, i) { void 0 === i && (i = null); var a = t.frag; a.loaded = e.loaded, this.hls.trigger(M.default.FRAG_LOAD_PROGRESS, { frag: a, stats: e, networkDetails: i }) }, r }(u); var U = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.KEY_LOADING) || this; return t.loaders = {}, t.decryptkey = null, t.decrypturl = null, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a = i.prototype; return a.destroy = function () { for (var e in this.loaders) { var t = this.loaders[e]; t && t.destroy() } this.loaders = {}, r.prototype.destroy.call(this) }, a.onKeyLoading = function (e) { var t = e.frag, r = t.type, i = this.loaders[r]; if (t.decryptdata) { var a = t.decryptdata.uri; if (a !== this.decrypturl || null === this.decryptkey) { var n = this.hls.config; if (i && (N.logger.warn("abort previous key loader for type:" + r), i.abort()), !a) return void N.logger.warn("key uri is falsy"); t.loader = this.loaders[r] = new n.loader(n), this.decrypturl = a, this.decryptkey = null; var s = { url: a, frag: t, responseType: "arraybuffer" }, o = { timeout: n.fragLoadingTimeOut, maxRetry: 0, retryDelay: n.fragLoadingRetryDelay, maxRetryDelay: n.fragLoadingMaxRetryTimeout }, l = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }; t.loader.load(s, o, l) } else this.decryptkey && (t.decryptdata.key = this.decryptkey, this.hls.trigger(M.default.KEY_LOADED, { frag: t })) } else N.logger.warn("Missing decryption data on fragment in onKeyLoading") }, a.loadsuccess = function (e, t, r) { var i = r.frag; i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(e.data), i.loader = void 0, delete this.loaders[i.type], this.hls.trigger(M.default.KEY_LOADED, { frag: i })) : N.logger.error("after key load, decryptdata unset") }, a.loaderror = function (e, t) { var r = t.frag, i = r.loader; i && i.abort(), delete this.loaders[r.type], this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.NETWORK_ERROR, details: h.ErrorDetails.KEY_LOAD_ERROR, fatal: !1, frag: r, response: e }) }, a.loadtimeout = function (e, t) { var r = t.frag, i = r.loader; i && i.abort(), delete this.loaders[r.type], this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.NETWORK_ERROR, details: h.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: !1, frag: r }) }, i }(u); var B = "NOT_LOADED", G = "APPENDING", j = "PARTIAL", K = "OK", H = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.BUFFER_APPENDED, M.default.FRAG_BUFFERED, M.default.FRAG_LOADED) || this; return t.bufferPadding = .2, t.fragments = Object.create(null), t.timeRanges = Object.create(null), t.config = e.config, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a = i.prototype; return a.destroy = function () { this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.config = null, u.prototype.destroy.call(this), r.prototype.destroy.call(this) }, a.getBufferedFrag = function (i, a) { var n = this.fragments, e = Object.keys(n).filter(function (e) { var t = n[e]; if (t.body.type !== a) return !1; if (!t.buffered) return !1; var r = t.body; return r.startPTS <= i && i <= r.endPTS }); if (0 === e.length) return null; var t = e.pop(); return n[t].body }, a.detectEvictedFragments = function (a, n) { var s, o, l = this; Object.keys(this.fragments).forEach(function (e) { var t = l.fragments[e]; if (!0 === t.buffered) { var r = t.range[a]; if (r) { s = r.time; for (var i = 0; i < s.length; i++)if (o = s[i], !1 === l.isTimeBuffered(o.startPTS, o.endPTS, n)) { l.removeFragment(t.body); break } } } }) }, a.detectPartialFragments = function (r) { var i = this, e = this.getFragmentKey(r), a = this.fragments[e]; a && (a.buffered = !0, Object.keys(this.timeRanges).forEach(function (e) { var t; r.hasElementaryStream(e) && (t = i.timeRanges[e], a.range[e] = i.getBufferedTimes(r.startPTS, r.endPTS, t)) })) }, a.getBufferedTimes = function (e, t, r) { for (var i, a, n = [], s = !1, o = 0; o < r.length; o++) { if (i = r.start(o) - this.bufferPadding, a = r.end(o) + this.bufferPadding, i <= e && t <= a) { n.push({ startPTS: Math.max(e, r.start(o)), endPTS: Math.min(t, r.end(o)) }); break } if (e < a && i < t) n.push({ startPTS: Math.max(e, r.start(o)), endPTS: Math.min(t, r.end(o)) }), s = !0; else if (t <= i) break } return { time: n, partial: s } }, a.getFragmentKey = function (e) { return e.type + "_" + e.level + "_" + e.urlId + "_" + e.sn }, a.getPartialFragment = function (r) { var i, a, n, s = this, o = null, l = 0; return Object.keys(this.fragments).forEach(function (e) { var t = s.fragments[e]; s.isPartial(t) && (a = t.body.startPTS - s.bufferPadding, n = t.body.endPTS + s.bufferPadding, a <= r && r <= n && (i = Math.min(r - a, n - r), l <= i && (o = t.body, l = i))) }), o }, a.getState = function (e) { var t = this.getFragmentKey(e), r = this.fragments[t], i = B; return void 0 !== r && (i = r.buffered ? !0 === this.isPartial(r) ? j : K : G), i }, a.isPartial = function (e) { return !0 === e.buffered && (void 0 !== e.range.video && !0 === e.range.video.partial || void 0 !== e.range.audio && !0 === e.range.audio.partial) }, a.isTimeBuffered = function (e, t, r) { for (var i, a, n = 0; n < r.length; n++) { if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, i <= e && t <= a) return !0; if (t <= i) return !1 } return !1 }, a.onFragLoaded = function (e) { var t = e.frag; Object(F.isFiniteNumber)(t.sn) && !t.bitrateTest && (this.fragments[this.getFragmentKey(t)] = { body: t, range: Object.create(null), buffered: !1 }) }, a.onBufferAppended = function (e) { var r = this; this.timeRanges = e.timeRanges, Object.keys(this.timeRanges).forEach(function (e) { var t = r.timeRanges[e]; r.detectEvictedFragments(e, t) }) }, a.onFragBuffered = function (e) { this.detectPartialFragments(e.frag) }, a.hasFragment = function (e) { var t = this.getFragmentKey(e); return void 0 !== this.fragments[t] }, a.removeFragment = function (e) { var t = this.getFragmentKey(e); delete this.fragments[t] }, a.removeAllFragments = function () { this.fragments = Object.create(null) }, i }(u), V = { search: function (e, t) { for (var r, i, a = 0, n = e.length - 1; a <= n;) { var s = t(i = e[r = (a + n) / 2 | 0]); if (0 < s) a = 1 + r; else { if (!(s < 0)) return i; n = r - 1 } } return null } }, Y = function () { function e() { } return e.isBuffered = function (e, t) { try { if (e) for (var r = e.buffered, i = 0; i < r.length; i++)if (t >= r.start(i) && t <= r.end(i)) return !0 } catch (e) { } return !1 }, e.bufferInfo = function (e, t, r) { try { if (e) { for (var i = e.buffered, a = [], n = 0; n < i.length; n++)a.push({ start: i.start(n), end: i.end(n) }); return this.bufferedInfo(a, t, r) } } catch (e) { } return { len: 0, start: t, end: t, nextStart: void 0 } }, e.bufferedInfo = function (e, t, r) { e.sort(function (e, t) { var r = e.start - t.start; return r || t.end - e.end }); var i = []; if (r) for (var a = 0; a < e.length; a++) { var n, s = i.length; s ? (n = i[s - 1].end, e[a].start - n < r ? e[a].end > n && (i[s - 1].end = e[a].end) : i.push(e[a])) : i.push(e[a]) } else i = e; for (var o, l = 0, u = t, d = t, c = 0; c < i.length; c++) { var h = i[c].start, f = i[c].end; if (h <= t + r && t < f) u = h, l = (d = f) - t; else if (t + r < h) { o = h; break } } return { len: l, start: u, end: d, nextStart: o } }, e }(), W = r("./node_modules/eventemitter3/index.js"), q = r("./node_modules/webworkify-webpack/index.js"), z = r("./src/demux/demuxer-inline.js"); function X() { return window.MediaSource || window.WebKitMediaSource } var Q = r("./src/utils/get-self-scope.js"); var $ = function (e) { var t, r; function i() { return e.apply(this, arguments) || this } return r = e, (t = i).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r, i.prototype.trigger = function (e) { for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; this.emit.apply(this, [e, e].concat(r)) }, i }(W.EventEmitter), J = Object(Q.getSelfScope)(), Z = X() || { isTypeSupported: function () { return !1 } }, ee = function () { function e(r, e) { var i = this; this.hls = r, this.id = e; function t(e, t) { (t = t || {}).frag = i.frag, t.id = i.id, r.trigger(e, t) } var a = this.observer = new $, n = r.config; a.on(M.default.FRAG_DECRYPTED, t), a.on(M.default.FRAG_PARSING_INIT_SEGMENT, t), a.on(M.default.FRAG_PARSING_DATA, t), a.on(M.default.FRAG_PARSED, t), a.on(M.default.ERROR, t), a.on(M.default.FRAG_PARSING_METADATA, t), a.on(M.default.FRAG_PARSING_USERDATA, t), a.on(M.default.INIT_PTS_FOUND, t); var s, o = { mp4: Z.isTypeSupported("video/mp4"), mpeg: Z.isTypeSupported("audio/mpeg"), mp3: Z.isTypeSupported('audio/mp4; codecs="mp3"') }, l = navigator.vendor; if (n.enableWorker && "undefined" != typeof Worker) { N.logger.log("demuxing in webworker"); try { s = this.w = q("./src/demux/demuxer-worker.js"), this.onwmsg = this.onWorkerMessage.bind(this), s.addEventListener("message", this.onwmsg), s.onerror = function (e) { r.trigger(M.default.ERROR, { type: h.ErrorTypes.OTHER_ERROR, details: h.ErrorDetails.INTERNAL_EXCEPTION, fatal: !0, event: "demuxerWorker", err: { message: e.message + " (" + e.filename + ":" + e.lineno + ")" } }) }, s.postMessage({ cmd: "init", typeSupported: o, vendor: l, id: e, config: JSON.stringify(n) }) } catch (e) { N.logger.warn("Error in worker:", e), N.logger.error("Error while initializing DemuxerWorker, fallback on DemuxerInline"), s && J.URL.revokeObjectURL(s.objectURL), this.demuxer = new z.default(a, o, n, l), this.w = void 0 } } else this.demuxer = new z.default(a, o, n, l) } var t = e.prototype; return t.destroy = function () { var e, t = this.w; t ? (t.removeEventListener("message", this.onwmsg), t.terminate(), this.w = null) : (e = this.demuxer) && (e.destroy(), this.demuxer = null); var r = this.observer; r && (r.removeAllListeners(), this.observer = null) }, t.push = function (e, t, r, i, a, n, s, o) { var l, u = this.w, d = Object(F.isFiniteNumber)(a.startPTS) ? a.startPTS : a.start, c = a.decryptdata, h = this.frag, f = !(h && a.cc === h.cc), g = !(h && a.level === h.level), p = h && a.sn === h.sn + 1, v = !g && p; f && N.logger.log(this.id + ":discontinuity detected"), g && N.logger.log(this.id + ":switch detected"), this.frag = a, u ? u.postMessage({ cmd: "demux", data: e, decryptdata: c, initSegment: t, audioCodec: r, videoCodec: i, timeOffset: d, discontinuity: f, trackSwitch: g, contiguous: v, duration: n, accurateTimeOffset: s, defaultInitPTS: o }, e instanceof ArrayBuffer ? [e] : []) : (l = this.demuxer) && l.push(e, c, t, r, i, d, f, g, v, n, s, o) }, t.onWorkerMessage = function (e) { var t = e.data, r = this.hls; switch (t.event) { case "init": J.URL.revokeObjectURL(this.w.objectURL); break; case M.default.FRAG_PARSING_DATA: t.data.data1 = new Uint8Array(t.data1), t.data2 && (t.data.data2 = new Uint8Array(t.data2)); default: t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data) } }, e }(); function te(e, t, r) { switch (t) { case "audio": e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(r); break; case "text": e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(r) } } function re(e, t, r) { var i = e[t], a = e[r], n = a.startPTS; Object(F.isFiniteNumber)(n) ? t < r ? (i.duration = n - i.start, i.duration < 0 && N.logger.warn("negative duration computed for frag " + i.sn + ",level " + i.level + ", there should be some duration drift between playlist and fragment!")) : (a.duration = i.start - n, a.duration < 0 && N.logger.warn("negative duration computed for frag " + a.sn + ",level " + a.level + ", there should be some duration drift between playlist and fragment!")) : a.start = t < r ? i.start + i.duration : Math.max(i.start - a.duration, 0) } function ie(e, t, r, i, a, n) { var s, o = r; Object(F.isFiniteNumber)(t.startPTS) && (s = Math.abs(t.startPTS - r), Object(F.isFiniteNumber)(t.deltaPTS) ? t.deltaPTS = Math.max(s, t.deltaPTS) : t.deltaPTS = s, o = Math.max(r, t.startPTS), r = Math.min(r, t.startPTS), i = Math.max(i, t.endPTS), a = Math.min(a, t.startDTS), n = Math.max(n, t.endDTS)); var l = r - t.start; t.start = t.startPTS = r, t.maxStartPTS = o, t.endPTS = i, t.startDTS = a, t.endDTS = n, t.duration = i - r; var u, d, c, h = t.sn; if (!e || h < e.startSN || h > e.endSN) return 0; for (u = h - e.startSN, (d = e.fragments)[u] = t, c = u; 0 < c; c--)re(d, c, c - 1); for (c = u; c < d.length - 1; c++)re(d, c, c + 1); return e.PTSKnown = !0, l } function ae(e, r) { r.initSegment && e.initSegment && (r.initSegment = e.initSegment); var i, a = 0; if (ne(e, r, function (e, t) { a = e.cc - t.cc, Object(F.isFiniteNumber)(e.startPTS) && (t.start = t.startPTS = e.startPTS, t.endPTS = e.endPTS, t.duration = e.duration, t.backtracked = e.backtracked, t.dropped = e.dropped, i = t), r.PTSKnown = !0 }), r.PTSKnown) { if (a) { N.logger.log("discontinuity sliding from playlist, take drift into account"); for (var t = r.fragments, n = 0; n < t.length; n++)t[n].cc += a } i ? ie(r, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : function (e, t) { var r = t.startSN - e.startSN, i = e.fragments, a = t.fragments; if (r < 0 || r > i.length) return; for (var n = 0; n < a.length; n++)a[n].start += i[r].start }(e, r), r.PTSKnown = e.PTSKnown } } function ne(e, t, r) { if (e && t) for (var i = Math.max(e.startSN, t.startSN) - t.startSN, a = Math.min(e.endSN, t.endSN) - t.startSN, n = t.startSN - e.startSN, s = i; s <= a; s++) { var o = e.fragments[n + s], l = t.fragments[s]; if (!o || !l) break; r(o, l, s) } } function se(e, t, r) { var i = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration), a = i / 2; return e && t.endSN === e.endSN && (i = a), r && (i = Math.max(a, i - (window.performance.now() - r))), Math.round(i) } var oe = { toString: function (e) { for (var t = "", r = e.length, i = 0; i < r; i++)t += "[" + e.start(i).toFixed(3) + "," + e.end(i).toFixed(3) + "]"; return t } }; function le(e, t) { var r = e.fragments, i = t.fragments; if (i.length && r.length) { var a = function (e, t) { for (var r = null, i = 0; i < e.length; i += 1) { var a = e[i]; if (a && a.cc === t) { r = a; break } } return r }(r, i[0].cc); if (a && (!a || a.startPTS)) return a; N.logger.log("No frag in previous level to align on") } else N.logger.log("No fragments to align") } function ue(r, e) { e.fragments.forEach(function (e) { var t; e && (t = e.start + r, e.start = e.startPTS = t, e.endPTS = t + e.duration) }), e.PTSKnown = !0 } function de(e, t, r) { !function (e, t, r) { { var i; !function (e, t, r) { var i = !1; return t && t.details && r && (r.endCC > r.startCC || e && e.cc < r.startCC) && (i = !0), i }(e, r, t) || (i = le(r.details, t)) && (N.logger.log("Adjusting PTS using last level due to CC increase within current level"), ue(i.start, t)) } }(e, r, t), !r.PTSKnown && t && function (e, t) { if (t && t.fragments.length) { if (!e.hasProgramDateTime || !t.hasProgramDateTime) return; var r = t.fragments[0].programDateTime, i = (e.fragments[0].programDateTime - r) / 1e3 + t.fragments[0].start; Object(F.isFiniteNumber)(i) && (N.logger.log("adjusting PTS using programDateTime delta, sliding:" + i.toFixed(3)), ue(i, e)) } }(r, t.details) } function ce(e, t, r) { if (null === t || !Array.isArray(e) || !e.length || !Object(F.isFiniteNumber)(t)) return null; if (t < (e[0].programDateTime || 0)) return null; if ((e[e.length - 1].endProgramDateTime || 0) <= t) return null; r = r || 0; for (var i, a, n, s, o = 0; o < e.length; ++o) { var l = e[o]; if (i = t, a = r, n = l, s = void 0, s = 1e3 * Math.min(a, n.duration + (n.deltaPTS ? n.deltaPTS : 0)), (n.endProgramDateTime || 0) - s > i) return l } return null } function he(e, t, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0); var a = e ? t[e.sn - t[0].sn + 1] : null; return a && !fe(r, i, a) ? a : V.search(t, fe.bind(null, r, i)) } function fe(e, t, r) { void 0 === e && (e = 0), void 0 === t && (t = 0); var i = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0)); return r.start + r.duration - i <= e ? 1 : r.start - i > e && r.start ? -1 : 0 } var ge = function () { function e(e, t, r, i) { this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1 } var t = e.prototype; return t.poll = function (e) { var t, r = this.config, i = this.media, a = this.stalled, n = i.currentTime, s = i.seeking, o = this.seeking && !s, l = !this.seeking && s; if (this.seeking = s, n !== e) return this.moved = !0, void (null !== a && (this.stallReported && (t = self.performance.now() - a, N.logger.warn("playback not stuck anymore @" + n + ", after " + Math.round(t) + "ms"), this.stallReported = !1), this.stalled = null, this.nudgeRetry = 0)); if ((l || o) && (this.stalled = null), !i.paused && !i.ended && 0 !== i.playbackRate && i.buffered.length) { var u = Y.bufferInfo(i, n, 0), d = 0 < u.len, c = u.nextStart || 0; if (d || c) { if (s) { if (2 < u.len || (!c || 2 < c - n)) return; this.moved = !1 } if (!this.moved && this.stalled) { var h = Math.max(c, u.start || 0) - n; if (0 < h && h <= 2) return void this._trySkipBufferHole(null) } var f, g, p = self.performance.now(); null !== a ? (f = p - a, !s && 250 <= f && this._reportStall(u.len), g = Y.bufferInfo(i, n, r.maxBufferHole), this._tryFixBufferStall(g, f)) : this.stalled = p } } }, t._tryFixBufferStall = function (e, t) { var r = this.config, i = this.fragmentTracker, a = this.media.currentTime, n = i.getPartialFragment(a); if (n && this._trySkipBufferHole(n)) return; e.len > r.maxBufferHole && t > 1e3 * r.highBufferWatchdogPeriod && (N.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer()) }, t._reportStall = function (e) { var t = this.hls, r = this.media; this.stallReported || (this.stallReported = !0, N.logger.warn("Playback stalling at @" + r.currentTime + " due to low buffer"), t.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_STALLED_ERROR, fatal: !1, buffer: e })) }, t._trySkipBufferHole = function (e) { for (var t = this.config, r = this.hls, i = this.media, a = i.currentTime, n = 0, s = 0; s < i.buffered.length; s++) { var o = i.buffered.start(s); if (a + t.maxBufferHole >= n && a < o) { var l = Math.max(o + .05, i.currentTime + .1); return N.logger.warn("skipping hole, adjusting currentTime from " + a + " to " + l), this.moved = !0, this.stalled = null, i.currentTime = l, e && r.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: !1, reason: "fragment loaded with buffer holes, seeking from " + a + " to " + l, frag: e }), l } n = i.buffered.end(s) } return 0 }, t._tryNudgeBuffer = function () { var e, t = this.config, r = this.hls, i = this.media, a = i.currentTime, n = (this.nudgeRetry || 0) + 1; (this.nudgeRetry = n) < t.nudgeMaxRetry ? (e = a + n * t.nudgeOffset, N.logger.warn("Nudging 'currentTime' from " + a + " to " + e), i.currentTime = e, r.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: !1 })) : (N.logger.error("Playhead still not moving while enough data buffered @" + a + " after " + t.nudgeMaxRetry + " nudges"), r.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_STALLED_ERROR, fatal: !0 })) }, e }(); var pe = function (n) { var e, t; function r(e) { for (var t, r = arguments.length, i = new Array(1 < r ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a]; return (t = n.call.apply(n, [this, e].concat(i)) || this)._boundTick = void 0, t._tickTimer = null, t._tickInterval = null, t._tickCallCount = 0, t._boundTick = t.tick.bind(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(t)), t } t = n, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var i = r.prototype; return i.onHandlerDestroying = function () { this.clearNextTick(), this.clearInterval() }, i.hasInterval = function () { return !!this._tickInterval }, i.hasNextTick = function () { return !!this._tickTimer }, i.setInterval = function (e) { return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e), !0) }, i.clearInterval = function () { return !!this._tickInterval && (self.clearInterval(this._tickInterval), !(this._tickInterval = null)) }, i.clearNextTick = function () { return !!this._tickTimer && (self.clearTimeout(this._tickTimer), !(this._tickTimer = null)) }, i.tick = function () { this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), 1 < this._tickCallCount && (this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)), this._tickCallCount = 0) }, i.doTick = function () { }, r }(u); var ve = "STOPPED", me = "STARTING", ye = "IDLE", Ee = "PAUSED", Te = "KEY_LOADING", be = "FRAG_LOADING", Se = "FRAG_LOADING_WAITING_RETRY", _e = "WAITING_TRACK", Re = "PARSING", Ae = "PARSED", ke = "BUFFER_FLUSHING", we = "ENDED", Le = "ERROR", De = "WAITING_INIT_PTS", Oe = "WAITING_LEVEL", Ce = function (e) { var t, r; function i() { return e.apply(this, arguments) || this } r = e, (t = i).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r; var a = i.prototype; return a.doTick = function () { }, a.startLoad = function () { }, a.stopLoad = function () { var e = this.fragCurrent; e && (e.loader && e.loader.abort(), this.fragmentTracker.removeFragment(e)), this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ve }, a._streamEnded = function (e, t) { var r = this.fragCurrent, i = this.fragmentTracker; if (t.live || !r || r.backtracked || r.sn !== t.endSN || e.nextStart) return !1; var a = i.getState(r); return a === j || a === K }, a.onMediaSeeking = function () { var e, t, r, i, a = this.config, n = this.media, s = this.mediaBuffer, o = this.state, l = n ? n.currentTime : null, u = Y.bufferInfo(s || n, l, this.config.maxBufferHole); Object(F.isFiniteNumber)(l) && N.logger.log("media seeking to " + l.toFixed(3)), o === be ? (e = this.fragCurrent, 0 === u.len && e && (t = a.maxFragLookUpTolerance, r = e.start - t, i = e.start + e.duration + t, l < r || i < l ? (e.loader && (N.logger.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), e.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = ye) : N.logger.log("seeking outside of buffer but within currently loaded fragment range"))) : o === we && (0 === u.len && (this.fragPrevious = null, this.fragCurrent = null), this.state = ye), n && (this.lastCurrentTime = l), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = l), this.tick() }, a.onMediaEnded = function () { this.startPosition = this.lastCurrentTime = 0 }, a.onHandlerDestroying = function () { this.stopLoad(), e.prototype.onHandlerDestroying.call(this) }, a.onHandlerDestroyed = function () { this.state = ve, this.fragmentTracker = null }, a.computeLivePosition = function (e, t) { var r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration; return e + Math.max(0, t.totalduration - r) }, i }(pe); function Ie(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var xe = function (i) { var e, t; function r(e, t) { var r = i.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHING, M.default.MANIFEST_LOADING, M.default.MANIFEST_PARSED, M.default.LEVEL_LOADED, M.default.KEY_LOADED, M.default.FRAG_LOADED, M.default.FRAG_LOAD_EMERGENCY_ABORTED, M.default.FRAG_PARSING_INIT_SEGMENT, M.default.FRAG_PARSING_DATA, M.default.FRAG_PARSED, M.default.ERROR, M.default.AUDIO_TRACK_SWITCHING, M.default.AUDIO_TRACK_SWITCHED, M.default.BUFFER_CREATED, M.default.BUFFER_APPENDED, M.default.BUFFER_FLUSHED) || this; return r.fragmentTracker = t, r.config = e.config, r.audioCodecSwap = !1, r._state = ve, r.stallReported = !1, r.gapController = null, r.altAudio = !1, r } t = i, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = r.prototype; return o.startLoad = function (e) { var t, r, i; this.levels ? (t = this.lastCurrentTime, r = this.hls, this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, this.startFragRequested || (-1 === (i = r.startLevel) && (i = 0, this.bitrateTest = !0), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1), 0 < t && -1 === e && (N.logger.log("override startPosition with lastCurrentTime @" + t.toFixed(3)), e = t), this.state = ye, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()) : (this.forceStartLoad = !0, this.state = ve) }, o.stopLoad = function () { this.forceStartLoad = !1, i.prototype.stopLoad.call(this) }, o.doTick = function () { switch (this.state) { case ke: this.fragLoadError = 0; break; case ye: this._doTickIdle(); break; case Oe: var e = this.levels[this.level]; e && e.details && (this.state = ye); break; case Se: var t = window.performance.now(), r = this.retryDate; (!r || r <= t || this.media && this.media.seeking) && (N.logger.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = ye) }this._checkBuffer(), this._checkFragmentChanged() }, o._doTickIdle = function () { var e = this.hls, t = e.config, r = this.media; if (void 0 !== this.levelLastLoaded && (r || !this.startFragRequested && t.startFragPrefetch)) { var i = this.loadedmetadata ? r.currentTime : this.nextLoadPosition, a = e.nextLoadLevel, n = this.levels[a]; if (n) { var s = n.bitrate, o = s ? Math.max(8 * t.maxBufferSize / s, t.maxBufferLength) : t.maxBufferLength; o = Math.min(o, t.maxMaxBufferLength); var l = Y.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, i, t.maxBufferHole), u = l.len; if (!(o <= u)) { N.logger.trace("buffer length of " + u.toFixed(3) + " is below max of " + o.toFixed(3) + ". checking for more payload ..."), this.level = e.nextLoadLevel = a; var d = n.details; if (!d || d.live && this.levelLastLoaded !== a) this.state = Oe; else { if (this._streamEnded(l, d)) { var c = {}; return this.altAudio && (c.type = "video"), this.hls.trigger(M.default.BUFFER_EOS, c), void (this.state = we) } this._fetchPayloadOrEos(i, l, d) } } } } }, o._fetchPayloadOrEos = function (e, t, r) { var i = this.fragPrevious, a = this.level, n = r.fragments, s = n.length; if (0 !== s) { var o, l = n[0].start, u = n[s - 1].start + n[s - 1].duration, d = t.end; if (r.initSegment && !r.initSegment.data) o = r.initSegment; else if (r.live) { var c = this.config.initialLiveManifestSize; if (s < c) return void N.logger.warn("Can not start playback of a level, reason: not enough fragments " + s + " < " + c); if (null === (o = this._ensureFragmentAtLivePoint(r, d, l, u, i, n, s))) return } else d < l && (o = n[0]); (o = o || this._findFragment(l, i, s, n, d, u, r)) && (o.encrypted ? (N.logger.log("Loading key for " + o.sn + " of [" + r.startSN + " ," + r.endSN + "],level " + a), this._loadKey(o)) : (N.logger.log("Loading " + o.sn + " of [" + r.startSN + " ," + r.endSN + "],level " + a + ", currentTime:" + e.toFixed(3) + ",bufferEnd:" + d.toFixed(3)), this._loadFragment(o))) } }, o._ensureFragmentAtLivePoint = function (e, t, r, i, a, n, s) { var o, l, u, d, c = this.hls.config, h = this.media, f = void 0 !== c.liveMaxLatencyDuration ? c.liveMaxLatencyDuration : c.liveMaxLatencyDurationCount * e.targetduration; return t < Math.max(r - c.maxFragLookUpTolerance, i - f) && (t = l = this.liveSyncPosition = this.computeLivePosition(r, e), h && !h.paused && h.readyState && h.duration > l && l > h.currentTime && (N.logger.log("buffer end: " + t.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + l.toFixed(3)), h.currentTime = l), this.nextLoadPosition = l), e.PTSKnown && i < t && h && h.readyState ? null : (this.startFragRequested && !e.PTSKnown && (a && (e.hasProgramDateTime ? (N.logger.log("live playlist, switching playlist, load frag with same PDT: " + a.programDateTime), o = ce(n, a.endProgramDateTime, c.maxFragLookUpTolerance)) : ((u = a.sn + 1) >= e.startSN && u <= e.endSN && (d = n[u - e.startSN], a.cc === d.cc && (o = d, N.logger.log("live playlist, switching playlist, load frag with next SN: " + o.sn))), o || (o = V.search(n, function (e) { return a.cc - e.cc })) && N.logger.log("live playlist, switching playlist, load frag with same CC: " + o.sn))), o || (o = n[Math.min(s - 1, Math.round(s / 2))], N.logger.log("live playlist, switching playlist, unknown, load middle frag : " + o.sn))), o) }, o._findFragment = function (e, t, r, i, a, n, s) { var o, l, u, d, c, h, f = this.hls.config; return (o = a < n ? he(t, i, a, a > n - f.maxFragLookUpTolerance ? 0 : f.maxFragLookUpTolerance) : i[r - 1]) && (l = o.sn - s.startSN, u = t && o.level === t.level, d = i[l - 1], c = i[1 + l], t && o.sn === t.sn && (u && !o.backtracked ? o.sn < s.endSN ? (h = t.deltaPTS) && h > f.maxBufferHole && t.dropped && l ? (o = d, N.logger.warn("Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this")) : (o = c, N.logger.log("Re-loading fragment with SN: " + o.sn)) : o = null : o.backtracked && (c && c.backtracked ? (N.logger.warn("Already backtracked from fragment " + c.sn + ", will not backtrack to fragment " + o.sn + ". Loading fragment " + c.sn), o = c) : (N.logger.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), o.dropped = 0, d ? (o = d).backtracked = !0 : l && (o = null))))), o }, o._loadKey = function (e) { this.state = Te, this.hls.trigger(M.default.KEY_LOADING, { frag: e }) }, o._loadFragment = function (e) { var t = this.fragmentTracker.getState(e); "initSegment" !== (this.fragCurrent = e).sn && (this.startFragRequested = !0), Object(F.isFiniteNumber)(e.sn) && !e.bitrateTest && (this.nextLoadPosition = e.start + e.duration), e.backtracked || t === B || t === j ? (e.autoLevel = this.hls.autoLevelEnabled, e.bitrateTest = this.bitrateTest, this.hls.trigger(M.default.FRAG_LOADING, { frag: e }), this.demuxer || (this.demuxer = new ee(this.hls, "main")), this.state = be) : t === G && this._reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e) }, o.getBufferedFrag = function (e) { return this.fragmentTracker.getBufferedFrag(e, l.MAIN) }, o.followingBufferedFrag = function (e) { return e ? this.getBufferedFrag(e.endPTS + .5) : null }, o._checkFragmentChanged = function () { var e, t, r, i, a = this.media; a && a.readyState && !1 === a.seeking && ((i = a.currentTime) > this.lastCurrentTime && (this.lastCurrentTime = i), Y.isBuffered(a, i) ? e = this.getBufferedFrag(i) : Y.isBuffered(a, i + .1) && (e = this.getBufferedFrag(i + .1)), !e || (t = e) !== this.fragPlaying && (this.hls.trigger(M.default.FRAG_CHANGED, { frag: t }), r = t.level, this.fragPlaying && this.fragPlaying.level === r || this.hls.trigger(M.default.LEVEL_SWITCHED, { level: r }), this.fragPlaying = t)) }, o.immediateLevelSwitch = function () { var e, t; N.logger.log("immediateLevelSwitch"), this.immediateSwitch || (this.immediateSwitch = !0, (e = this.media) ? (t = e.paused, e.pause()) : t = !0, this.previouslyPaused = t); var r = this.fragCurrent; r && r.loader && r.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY) }, o.immediateLevelSwitchEnd = function () { var e = this.media; e && e.buffered.length && (this.immediateSwitch = !1, Y.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play()) }, o.nextLevelSwitch = function () { var e, t, r, i, a, n, s, o = this.media; o && o.readyState && ((s = this.getBufferedFrag(o.currentTime)) && 1 < s.startPTS && this.flushMainBuffer(0, s.startPTS - 1), i = o.paused ? 0 : (e = this.hls.nextLoadLevel, t = this.levels[e], (r = this.fragLastKbps) && this.fragCurrent ? this.fragCurrent.duration * t.bitrate / (1e3 * r) + 1 : 0), (n = (n = this.getBufferedFrag(o.currentTime + i)) && this.followingBufferedFrag(n)) && ((a = this.fragCurrent) && a.loader && a.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(n.maxStartPTS, Number.POSITIVE_INFINITY))) }, o.flushMainBuffer = function (e, t) { this.state = ke; var r = { startOffset: e, endOffset: t }; this.altAudio && (r.type = "video"), this.hls.trigger(M.default.BUFFER_FLUSHING, r) }, o.onMediaAttached = function (e) { var t = this.media = this.mediaBuffer = e.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("seeked", this.onvseeked), t.addEventListener("ended", this.onvended); var r = this.config; this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition), this.gapController = new ge(r, t, this.fragmentTracker, this.hls) }, o.onMediaDetaching = function () { var e = this.media; e && e.ended && (N.logger.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0); var t = this.levels; t && t.forEach(function (e) { e.details && e.details.fragments.forEach(function (e) { e.backtracked = void 0 }) }), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("seeked", this.onvseeked), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.fragmentTracker.removeAllFragments(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad() }, o.onMediaSeeked = function () { var e = this.media, t = e ? e.currentTime : void 0; Object(F.isFiniteNumber)(t) && N.logger.log("media seeked to " + t.toFixed(3)), this.tick() }, o.onManifestLoading = function () { N.logger.log("trigger BUFFER_RESET"), this.hls.trigger(M.default.BUFFER_RESET), this.fragmentTracker.removeAllFragments(), this.stalled = !1, this.startPosition = this.lastCurrentTime = 0 }, o.onManifestParsed = function (e) { var t, r = !1, i = !1; e.levels.forEach(function (e) { (t = e.audioCodec) && (-1 !== t.indexOf("mp4a.40.2") && (r = !0), -1 !== t.indexOf("mp4a.40.5") && (i = !0)) }), this.audioCodecSwitch = r && i, this.audioCodecSwitch && N.logger.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.altAudio = e.altAudio, this.levels = e.levels, this.startFragRequested = !1; var a = this.config; (a.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(a.startPosition) }, o.onLevelLoaded = function (e) { var t, r, i = e.details, a = e.level, n = this.levels[this.levelLastLoaded], s = this.levels[a], o = i.totalduration, l = 0; N.logger.log("level " + a + " loaded [" + i.startSN + "," + i.endSN + "],duration:" + o), i.live ? (t = s.details) && 0 < i.fragments.length ? (ae(t, i), l = i.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(l, t), i.PTSKnown && Object(F.isFiniteNumber)(l) ? N.logger.log("live playlist sliding:" + l.toFixed(3)) : (N.logger.log("live playlist - outdated PTS, unknown sliding"), de(this.fragPrevious, n, i))) : (N.logger.log("live playlist - first load, unknown sliding"), i.PTSKnown = !1, de(this.fragPrevious, n, i)) : i.PTSKnown = !1, s.details = i, this.levelLastLoaded = a, this.hls.trigger(M.default.LEVEL_UPDATED, { details: i, level: a }), !1 === this.startFragRequested && (-1 !== this.startPosition && -1 !== this.lastCurrentTime || (r = i.startTimeOffset, Object(F.isFiniteNumber)(r) ? (r < 0 && (N.logger.log("negative start time offset " + r + ", count from end of last fragment"), r = l + o + r), N.logger.log("start time offset found in playlist, adjust startPosition to " + r), this.startPosition = r) : i.live ? (this.startPosition = this.computeLivePosition(l, i), N.logger.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0, this.lastCurrentTime = this.startPosition), this.nextLoadPosition = this.startPosition), this.state === Oe && (this.state = ye), this.tick() }, o.onKeyLoaded = function () { this.state === Te && (this.state = ye, this.tick()) }, o.onFragLoaded = function (e) { var t, r, i, a, n, s, o = this.fragCurrent, l = this.hls, u = this.levels, d = this.media, c = e.frag; this.state === be && o && "main" === c.type && c.level === o.level && c.sn === o.sn && (t = e.stats, i = (r = u[o.level]).details, this.bitrateTest = !1, this.stats = t, N.logger.log("Loaded " + o.sn + " of [" + i.startSN + " ," + i.endSN + "],level " + o.level), c.bitrateTest && l.nextLoadLevel ? (this.state = ye, this.startFragRequested = !1, t.tparsed = t.tbuffered = window.performance.now(), l.trigger(M.default.FRAG_BUFFERED, { stats: t, frag: o, id: "main" }), this.tick()) : "initSegment" === c.sn ? (this.state = ye, t.tparsed = t.tbuffered = window.performance.now(), i.initSegment.data = e.payload, l.trigger(M.default.FRAG_BUFFERED, { stats: t, frag: o, id: "main" }), this.tick()) : (N.logger.log("Parsing " + o.sn + " of [" + i.startSN + " ," + i.endSN + "],level " + o.level + ", cc " + o.cc), this.state = Re, this.pendingBuffering = !0, this.appended = !1, c.bitrateTest && (c.bitrateTest = !1, this.fragmentTracker.onFragLoaded({ frag: c })), a = !(d && d.seeking) && (i.PTSKnown || !i.live), n = i.initSegment ? i.initSegment.data : [], s = this._getAudioCodec(r), (this.demuxer = this.demuxer || new ee(this.hls, "main")).push(e.payload, n, s, r.videoCodec, o, i.totalduration, a))), this.fragLoadError = 0 }, o.onFragParsingInitSegment = function (e) { var t = this.fragCurrent, r = e.frag; if (t && "main" === e.id && r.sn === t.sn && r.level === t.level && this.state === Re) { var i, a, n, s, o = e.tracks; for (i in o.audio && this.altAudio && delete o.audio, (a = o.audio) && (n = this.levels[this.level].audioCodec, s = navigator.userAgent.toLowerCase(), n && this.audioCodecSwap && (N.logger.log("swapping playlist audio codec"), n = -1 !== n.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), this.audioCodecSwitch && 1 !== a.metadata.channelCount && -1 === s.indexOf("firefox") && (n = "mp4a.40.5"), -1 !== s.indexOf("android") && "audio/mpeg" !== a.container && (n = "mp4a.40.2", N.logger.log("Android: force audio codec to " + n)), a.levelCodec = n, a.id = e.id), (a = o.video) && (a.levelCodec = this.levels[this.level].videoCodec, a.id = e.id), this.hls.trigger(M.default.BUFFER_CODECS, o), o) { a = o[i], N.logger.log("main track:" + i + ",container:" + a.container + ",codecs[level/parsed]=[" + a.levelCodec + "/" + a.codec + "]"); var l = a.initSegment; l && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(M.default.BUFFER_APPENDING, { type: i, data: l, parent: "main", content: "initSegment" })) } this.tick() } }, o.onFragParsingData = function (t) { var r = this, e = this.fragCurrent, i = t.frag; if (e && "main" === t.id && i.sn === e.sn && i.level === e.level && ("audio" !== t.type || !this.altAudio) && this.state === Re) { var a = this.levels[this.level], n = e; if (Object(F.isFiniteNumber)(t.endPTS) || (t.endPTS = t.startPTS + e.duration, t.endDTS = t.startDTS + e.duration), !0 === t.hasAudio && n.addElementaryStream(f.AUDIO), !0 === t.hasVideo && n.addElementaryStream(f.VIDEO), N.logger.log("Parsed " + t.type + ",PTS:[" + t.startPTS.toFixed(3) + "," + t.endPTS.toFixed(3) + "],DTS:[" + t.startDTS.toFixed(3) + "/" + t.endDTS.toFixed(3) + "],nb:" + t.nb + ",dropped:" + (t.dropped || 0)), "video" === t.type) if (n.dropped = t.dropped, n.dropped) if (n.backtracked) N.logger.warn("Already backtracked on this fragment, appending with the gap", n.sn); else { var s = a.details; if (!s || n.sn !== s.startSN) return N.logger.warn("missing video frame(s), backtracking fragment", n.sn), this.fragmentTracker.removeFragment(n), n.backtracked = !0, this.nextLoadPosition = t.startPTS, this.state = ye, this.fragPrevious = n, void this.tick(); N.logger.warn("missing video frame(s) on first frag, appending with gap", n.sn) } else n.backtracked = !1; var o = ie(a.details, n, t.startPTS, t.endPTS, t.startDTS, t.endDTS), l = this.hls; l.trigger(M.default.LEVEL_PTS_UPDATED, { details: a.details, level: this.level, drift: o, type: t.type, start: t.startPTS, end: t.endPTS }), [t.data1, t.data2].forEach(function (e) { e && e.length && r.state === Re && (r.appended = !0, r.pendingBuffering = !0, l.trigger(M.default.BUFFER_APPENDING, { type: t.type, data: e, parent: "main", content: "data" })) }), this.tick() } }, o.onFragParsed = function (e) { var t = this.fragCurrent, r = e.frag; t && "main" === e.id && r.sn === t.sn && r.level === t.level && this.state === Re && (this.stats.tparsed = window.performance.now(), this.state = Ae, this._checkAppendedParsed()) }, o.onAudioTrackSwitching = function (e) { var t, r, i = !!e.url, a = e.id; i || (this.mediaBuffer !== this.media && (N.logger.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media, (t = this.fragCurrent).loader && (N.logger.log("switching to main audio track, cancel main fragment load"), t.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ye), (r = this.hls).trigger(M.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), r.trigger(M.default.AUDIO_TRACK_SWITCHED, { id: a }), this.altAudio = !1) }, o.onAudioTrackSwitched = function (e) { var t, r = e.id, i = !!this.hls.audioTracks[r].url; !i || (t = this.videoBuffer) && this.mediaBuffer !== t && (N.logger.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = t), this.altAudio = i, this.tick() }, o.onBufferCreated = function (e) { var t, r, i = e.tracks, a = !1; for (var n in i) { var s = i[n]; "main" === s.id ? (t = s, "video" === (r = n) && (this.videoBuffer = i[n].buffer)) : a = !0 } a && t ? (N.logger.log("alternate track found, use " + r + ".buffered to schedule main fragment loading"), this.mediaBuffer = t.buffer) : this.mediaBuffer = this.media }, o.onBufferAppended = function (e) { var t; "main" === e.parent && ((t = this.state) !== Re && t !== Ae || (this.pendingBuffering = 0 < e.pending, this._checkAppendedParsed())) }, o._checkAppendedParsed = function () { var e, t, r; this.state !== Ae || this.appended && this.pendingBuffering || ((e = this.fragCurrent) && (t = this.mediaBuffer ? this.mediaBuffer : this.media, N.logger.log("main buffered : " + oe.toString(t.buffered)), this.fragPrevious = e, (r = this.stats).tbuffered = window.performance.now(), this.fragLastKbps = Math.round(8 * r.total / (r.tbuffered - r.tfirst)), this.hls.trigger(M.default.FRAG_BUFFERED, { stats: r, frag: e, id: "main" }), this.state = ye), this.tick()) }, o.onError = function (e) { var t = e.frag || this.fragCurrent; if (!t || "main" === t.type) { var r, i = !!this.media && Y.isBuffered(this.media, this.media.currentTime) && Y.isBuffered(this.media, this.media.currentTime + .5); switch (e.details) { case h.ErrorDetails.FRAG_LOAD_ERROR: case h.ErrorDetails.FRAG_LOAD_TIMEOUT: case h.ErrorDetails.KEY_LOAD_ERROR: case h.ErrorDetails.KEY_LOAD_TIMEOUT: e.fatal || (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry ? (r = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout), N.logger.warn("mediaController: frag loading failed, retry in " + r + " ms"), this.retryDate = window.performance.now() + r, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = Se) : (N.logger.error("mediaController: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.state = Le)); break; case h.ErrorDetails.LEVEL_LOAD_ERROR: case h.ErrorDetails.LEVEL_LOAD_TIMEOUT: this.state !== Le && (e.fatal ? (this.state = Le, N.logger.warn("streamController: " + e.details + ",switch to " + this.state + " state ...")) : e.levelRetry || this.state !== Oe || (this.state = ye)); break; case h.ErrorDetails.BUFFER_FULL_ERROR: "main" !== e.parent || this.state !== Re && this.state !== Ae || (i ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = ye) : (N.logger.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY))) } } }, o._reduceMaxBufferLength = function (e) { var t = this.config; return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, N.logger.warn("main:reduce max buffer length to " + t.maxMaxBufferLength + "s"), !0) }, o._checkBuffer = function () { var e, t = this.media; t && 0 !== t.readyState && (e = (this.mediaBuffer ? this.mediaBuffer : t).buffered, !this.loadedmetadata && e.length ? (this.loadedmetadata = !0, this._seekToStartPos()) : this.immediateSwitch ? this.immediateLevelSwitchEnd() : this.gapController.poll(this.lastCurrentTime, e)) }, o.onFragLoadEmergencyAborted = function () { this.state = ye, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick() }, o.onBufferFlushed = function () { var e = this.mediaBuffer ? this.mediaBuffer : this.media; e && this.fragmentTracker.detectEvictedFragments(f.VIDEO, e.buffered), this.state = ye, this.fragPrevious = null }, o.swapAudioCodec = function () { this.audioCodecSwap = !this.audioCodecSwap }, o._seekToStartPos = function () { var e = this.media, t = e.currentTime, r = e.seeking ? t : this.startPosition; t !== r && 0 <= r && (N.logger.log("target start position not buffered, seek to buffered.start(0) " + r + " from current time " + t + " "), e.currentTime = r) }, o._getAudioCodec = function (e) { var t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && (N.logger.log("swapping playlist audio codec"), t = t && (-1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5")), t }, a = r, (n = [{ key: "state", set: function (e) { var t; this.state !== e && (t = this.state, this._state = e, N.logger.log("main stream-controller: " + t + "->" + e), this.hls.trigger(M.default.STREAM_STATE_TRANSITION, { previousState: t, nextState: e })) }, get: function () { return this._state } }, { key: "currentLevel", get: function () { var e = this.media; if (e) { var t = this.getBufferedFrag(e.currentTime); if (t) return t.level } return -1 } }, { key: "nextBufferedFrag", get: function () { var e = this.media; return e ? this.followingBufferedFrag(this.getBufferedFrag(e.currentTime)) : null } }, { key: "nextLevel", get: function () { var e = this.nextBufferedFrag; return e ? e.level : -1 } }, { key: "liveSyncPosition", get: function () { return this._liveSyncPosition }, set: function (e) { this._liveSyncPosition = e } }]) && Ie(a.prototype, n), s && Ie(a, s), r }(Ce); function Pe(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } window.performance; var Fe, Me = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.MANIFEST_LOADED, M.default.LEVEL_LOADED, M.default.AUDIO_TRACK_SWITCHED, M.default.FRAG_LOADED, M.default.ERROR) || this; return t.canload = !1, t.currentLevelIndex = null, t.manualLevelIndex = -1, t.timer = null, Fe = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = i.prototype; return o.onHandlerDestroying = function () { this.clearTimer(), this.manualLevelIndex = -1 }, o.clearTimer = function () { null !== this.timer && (clearTimeout(this.timer), this.timer = null) }, o.startLoad = function () { var e = this._levels; this.canload = !0, this.levelRetryCount = 0, e && e.forEach(function (e) { e.loadError = 0; var t = e.details; t && t.live && (e.details = void 0) }), null !== this.timer && this.loadLevel() }, o.stopLoad = function () { this.canload = !1 }, o.onManifestLoaded = function (e) { var t, r = [], i = [], a = {}, n = null, s = !1, o = !1; if (e.levels.forEach(function (e) { var t = e.attrs; e.loadError = 0, e.fragmentError = !1, s = s || !!e.videoCodec, o = o || !!e.audioCodec, Fe && e.audioCodec && -1 !== e.audioCodec.indexOf("mp4a.40.34") && (e.audioCodec = void 0), (n = a[e.bitrate]) ? n.url.push(e.url) : (e.url = [e.url], e.urlId = 0, a[e.bitrate] = e, r.push(e)), t && (t.AUDIO && (o = !0, te(n || e, "audio", t.AUDIO)), t.SUBTITLES && te(n || e, "text", t.SUBTITLES)) }), s && o && (r = r.filter(function (e) { return !!e.videoCodec })), r = r.filter(function (e) { var t = e.audioCodec, r = e.videoCodec; return (!t || b(t, "audio")) && (!r || b(r, "video")) }), e.audioTracks && (i = e.audioTracks.filter(function (e) { return !e.audioCodec || b(e.audioCodec, "audio") })).forEach(function (e, t) { e.id = t }), 0 < r.length) { t = r[0].bitrate, r.sort(function (e, t) { return e.bitrate - t.bitrate }), this._levels = r; for (var l = 0; l < r.length; l++)if (r[l].bitrate === t) { this._firstLevel = l, N.logger.log("manifest loaded," + r.length + " level(s) found, first bitrate:" + t); break } this.hls.trigger(M.default.MANIFEST_PARSED, { levels: r, audioTracks: i, firstLevel: this._firstLevel, stats: e.stats, audio: o, video: s, altAudio: i.some(function (e) { return !!e.url }) }) } else this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: this.hls.url, reason: "no level with compatible codecs found in manifest" }) }, o.setLevelInternal = function (e) { var t, r, i, a, n = this._levels, s = this.hls; 0 <= e && e < n.length ? (this.clearTimer(), this.currentLevelIndex !== e && (N.logger.log("switching to level " + e), (t = n[this.currentLevelIndex = e]).level = e, s.trigger(M.default.LEVEL_SWITCHING, t)), (i = (r = n[e]).details) && !i.live || (a = r.urlId, s.trigger(M.default.LEVEL_LOADING, { url: r.url[a], level: e, id: a }))) : s.trigger(M.default.ERROR, { type: h.ErrorTypes.OTHER_ERROR, details: h.ErrorDetails.LEVEL_SWITCH_ERROR, level: e, fatal: !1, reason: "invalid level idx" }) }, o.onError = function (e) { if (e.fatal) e.type === h.ErrorTypes.NETWORK_ERROR && this.clearTimer(); else { var t, r = !1, i = !1; switch (e.details) { case h.ErrorDetails.FRAG_LOAD_ERROR: case h.ErrorDetails.FRAG_LOAD_TIMEOUT: case h.ErrorDetails.KEY_LOAD_ERROR: case h.ErrorDetails.KEY_LOAD_TIMEOUT: t = e.frag.level, i = !0; break; case h.ErrorDetails.LEVEL_LOAD_ERROR: case h.ErrorDetails.LEVEL_LOAD_TIMEOUT: t = e.context.level, r = !0; break; case h.ErrorDetails.REMUX_ALLOC_ERROR: t = e.level, r = !0 }void 0 !== t && this.recoverLevel(e, t, r, i) } }, o.recoverLevel = function (e, t, r, i) { var a, n, s, o = this, l = this.hls.config, u = e.details, d = this._levels[t]; if (d.loadError++, d.fragmentError = i, r) { if (!(this.levelRetryCount + 1 <= l.levelLoadingMaxRetry)) return N.logger.error("level controller, cannot recover from " + u + " error"), this.currentLevelIndex = null, this.clearTimer(), void (e.fatal = !0); n = Math.min(Math.pow(2, this.levelRetryCount) * l.levelLoadingRetryDelay, l.levelLoadingMaxRetryTimeout), this.timer = setTimeout(function () { return o.loadLevel() }, n), e.levelRetry = !0, this.levelRetryCount++, N.logger.warn("level controller, " + u + ", retry in " + n + " ms, current retry count is " + this.levelRetryCount) } (r || i) && (1 < (a = d.url.length) && d.loadError < a ? (d.urlId = (d.urlId + 1) % a, d.details = void 0, N.logger.warn("level controller, " + u + " for level " + t + ": switching to redundant URL-id " + d.urlId)) : -1 === this.manualLevelIndex ? (s = 0 === t ? this._levels.length - 1 : t - 1, N.logger.warn("level controller, " + u + ": switch to " + s), this.hls.nextAutoLevel = this.currentLevelIndex = s) : i && (N.logger.warn("level controller, " + u + ": reload a fragment"), this.currentLevelIndex = null)) }, o.onFragLoaded = function (e) { var t, r = e.frag; void 0 === r || "main" !== r.type || void 0 !== (t = this._levels[r.level]) && (t.fragmentError = !1, t.loadError = 0, this.levelRetryCount = 0) }, o.onLevelLoaded = function (e) { var t, r, i = this, a = e.level, n = e.details; a === this.currentLevelIndex && ((t = this._levels[a]).fragmentError || (t.loadError = 0, this.levelRetryCount = 0), n.live ? (r = se(t.details, n, e.stats.trequest), N.logger.log("live playlist, reload in " + Math.round(r) + " ms"), this.timer = setTimeout(function () { return i.loadLevel() }, r)) : this.clearTimer()) }, o.onAudioTrackSwitched = function (e) { var t = this.hls.audioTracks[e.id].groupId, r = this.hls.levels[this.currentLevelIndex]; if (r && r.audioGroupIds) { for (var i = -1, a = 0; a < r.audioGroupIds.length; a++)if (r.audioGroupIds[a] === t) { i = a; break } i !== r.urlId && (r.urlId = i, this.startLoad()) } }, o.loadLevel = function () { var e, t, r, i; N.logger.debug("call to loadLevel"), null === this.currentLevelIndex || !this.canload || "object" == typeof (e = this._levels[this.currentLevelIndex]) && 0 < e.url.length && (t = this.currentLevelIndex, r = e.urlId, i = e.url[r], N.logger.log("Attempt loading level index " + t + " with URL-id " + r), this.hls.trigger(M.default.LEVEL_LOADING, { url: i, level: t, id: r })) }, a = i, (n = [{ key: "levels", get: function () { return this._levels } }, { key: "level", get: function () { return this.currentLevelIndex }, set: function (e) { var t = this._levels; t && (e = Math.min(e, t.length - 1), this.currentLevelIndex === e && t[e].details || this.setLevelInternal(e)) } }, { key: "manualLevel", get: function () { return this.manualLevelIndex }, set: function (e) { this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e) } }, { key: "firstLevel", get: function () { return this._firstLevel }, set: function (e) { this._firstLevel = e } }, { key: "startLevel", get: function () { if (void 0 !== this._startLevel) return this._startLevel; var e = this.hls.config.startLevel; return void 0 !== e ? e : this._firstLevel }, set: function (e) { this._startLevel = e } }, { key: "nextLoadLevel", get: function () { return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel }, set: function (e) { this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e) } }]) && Pe(a.prototype, n), s && Pe(a, s), i }(u), Ne = r("./src/demux/id3.js"); function Ue(e, t) { var r; try { r = new Event("addtrack") } catch (e) { (r = document.createEvent("Event")).initEvent("addtrack", !1, !1) } r.track = e, t.dispatchEvent(r) } function Be(e) { if (e && e.cues) for (; 0 < e.cues.length;)e.removeCue(e.cues[0]) } var Ge = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHING, M.default.FRAG_PARSING_METADATA, M.default.LIVE_BACK_BUFFER_REACHED) || this; return t.id3Track = void 0, t.media = void 0, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a = i.prototype; return a.destroy = function () { u.prototype.destroy.call(this) }, a.onMediaAttached = function (e) { this.media = e.media, this.media }, a.onMediaDetaching = function () { Be(this.id3Track), this.id3Track = void 0, this.media = void 0 }, a.getID3Track = function (e) { for (var t = 0; t < e.length; t++) { var r = e[t]; if ("metadata" === r.kind && "id3" === r.label) return Ue(r, this.media), r } return this.media.addTextTrack("metadata", "id3") }, a.onFragParsingMetadata = function (e) { var t = e.frag, r = e.samples; this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = "hidden"); for (var i = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, a = 0; a < r.length; a++) { var n = Ne.default.getID3Frames(r[a].data); if (n) { var s = r[a].pts, o = a < r.length - 1 ? r[a + 1].pts : t.endPTS; s === o ? o += 1e-4 : o < s && (N.logger.warn("detected an id3 sample with endTime < startTime, adjusting endTime to (startTime + 0.25)"), o = s + .25); for (var l = 0; l < n.length; l++) { var u, d = n[l]; Ne.default.isTimeStampFrame(d) || ((u = new i(s, o, "")).value = d, this.id3Track.addCue(u)) } } } }, a.onLiveBackBufferReached = function (e) { var t = e.bufferEnd, r = this.id3Track; if (r && r.cues && r.cues.length) { var i = function (e, t) { if (t < e[0].endTime) return e[0]; if (t > e[e.length - 1].endTime) return e[e.length - 1]; for (var r = 0, i = e.length - 1; r <= i;) { var a = Math.floor((i + r) / 2); if (t < e[a].endTime) i = a - 1; else { if (!(t > e[a].endTime)) return e[a]; r = a + 1 } } return e[r].endTime - t < t - e[i].endTime ? e[r] : e[i] }(r.cues, t); if (i) for (; r.cues[0] !== i;)r.removeCue(r.cues[0]) } }, i }(u); var je = function () { function e(e) { this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = 0, this.totalWeight_ = 0 } var t = e.prototype; return t.sample = function (e, t) { var r = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e }, t.getTotalWeight = function () { return this.totalWeight_ }, t.getEstimate = function () { if (this.alpha_) { var e = 1 - Math.pow(this.alpha_, this.totalWeight_); return this.estimate_ / e } return this.estimate_ }, e }(), Ke = function () { function e(e, t, r, i) { this.hls = void 0, this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.hls = e, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new je(t), this.fast_ = new je(r) } var t = e.prototype; return t.sample = function (e, t) { var r = (e = Math.max(e, this.minDelayMs_)) / 1e3, i = 8 * t / r; this.fast_.sample(r, i), this.slow_.sample(r, i) }, t.canEstimate = function () { var e = this.fast_; return e && e.getTotalWeight() >= this.minWeight_ }, t.getEstimate = function () { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ }, t.destroy = function () { }, e }(); function He(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var Ve = window.performance, Ye = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.FRAG_LOADING, M.default.FRAG_LOADED, M.default.FRAG_BUFFERED, M.default.ERROR) || this; return t.lastLoadedFragLevel = 0, t._nextAutoLevel = -1, t.hls = e, t.timer = null, t._bwEstimator = null, t.onCheck = t._abandonRulesCheck.bind(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(t)), t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = i.prototype; return o.destroy = function () { this.clearTimer(), u.prototype.destroy.call(this) }, o.onFragLoading = function (e) { var t, r, i, a, n, s = e.frag; "main" === s.type && (this.timer || (this.fragCurrent = s, this.timer = setInterval(this.onCheck, 100)), this._bwEstimator || (r = (t = this.hls).config, i = s.level, n = t.levels[i].details.live ? (a = r.abrEwmaFastLive, r.abrEwmaSlowLive) : (a = r.abrEwmaFastVoD, r.abrEwmaSlowVoD), this._bwEstimator = new Ke(t, n, a, r.abrEwmaDefaultEstimate))) }, o._abandonRulesCheck = function () { var e = this.hls, t = e.media, r = this.fragCurrent; if (r) { var i = r.loader, a = e.minAutoLevel; if (!i || i.stats && i.stats.aborted) return N.logger.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), void (this._nextAutoLevel = -1); var n = i.stats; if (t && n && (!t.paused && 0 !== t.playbackRate || !t.readyState) && r.autoLevel && r.level) { var s = Ve.now() - n.trequest, o = Math.abs(t.playbackRate); if (s > 500 * r.duration / o) { var l = e.levels, u = Math.max(1, n.bw ? n.bw / 8 : 1e3 * n.loaded / s), d = l[r.level], c = d.realBitrate ? Math.max(d.realBitrate, d.bitrate) : d.bitrate, h = n.total ? n.total : Math.max(n.loaded, Math.round(r.duration * c / 8)), f = t.currentTime, g = (h - n.loaded) / u, p = (Y.bufferInfo(t, f, e.config.maxBufferHole).end - f) / o; if (p < 2 * r.duration / o && p < g) { for (var v = r.level - 1; a < v; v--) { var m = l[v].realBitrate ? Math.max(l[v].realBitrate, l[v].bitrate) : l[v].bitrate; if (r.duration * m / (6.4 * u) < p) break } void 0 < g && (N.logger.warn("loading too slow, abort fragment loading and switch to level " + v + ":fragLoadedDelay[" + v + "]<fragLoadedDelay[" + (r.level - 1) + "];bufferStarvationDelay:" + (void 0).toFixed(1) + "<" + g.toFixed(1) + ":" + p.toFixed(1)), e.nextLoadLevel = v, this._bwEstimator.sample(s, n.loaded), i.abort(), this.clearTimer(), e.trigger(M.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: r, stats: n })) } } } } }, o.onFragLoaded = function (e) { var t, r, i, a, n = e.frag; "main" === n.type && Object(F.isFiniteNumber)(n.sn) && (this.clearTimer(), this.lastLoadedFragLevel = n.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate && (r = ((t = this.hls.levels[n.level]).loaded ? t.loaded.bytes : 0) + e.stats.loaded, i = (t.loaded ? t.loaded.duration : 0) + e.frag.duration, t.loaded = { bytes: r, duration: i }, t.realBitrate = Math.round(8 * r / i)), e.frag.bitrateTest && ((a = e.stats).tparsed = a.tbuffered = a.tload, this.onFragBuffered(e))) }, o.onFragBuffered = function (e) { var t, r = e.stats, i = e.frag; !0 === r.aborted || "main" !== i.type || !Object(F.isFiniteNumber)(i.sn) || i.bitrateTest && r.tload !== r.tbuffered || (t = r.tparsed - r.trequest, N.logger.log("latency/loading/parsing/append/kbps:" + Math.round(r.tfirst - r.trequest) + "/" + Math.round(r.tload - r.tfirst) + "/" + Math.round(r.tparsed - r.tload) + "/" + Math.round(r.tbuffered - r.tparsed) + "/" + Math.round(8 * r.loaded / (r.tbuffered - r.trequest))), this._bwEstimator.sample(t, r.loaded), r.bwEstimate = this._bwEstimator.getEstimate(), i.bitrateTest ? this.bitrateTestDelay = t / 1e3 : this.bitrateTestDelay = 0) }, o.onError = function (e) { switch (e.details) { case h.ErrorDetails.FRAG_LOAD_ERROR: case h.ErrorDetails.FRAG_LOAD_TIMEOUT: this.clearTimer() } }, o.clearTimer = function () { clearInterval(this.timer), this.timer = null }, o._findBestLevel = function (e, t, r, i, a, n, s, o, l) { for (var u = a; i <= u; u--) { var d = l[u]; if (d) { var c = d.details, h = c ? c.totalduration / c.fragments.length : t, f = !!c && c.live, g = void 0, g = u <= e ? s * r : o * r, p = l[u].realBitrate ? Math.max(l[u].realBitrate, l[u].bitrate) : l[u].bitrate, v = p * h / g; if (N.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + u + "/" + Math.round(g) + "/" + p + "/" + h + "/" + n + "/" + v), p < g && (!v || f && !this.bitrateTestDelay || v < n)) return u } } return -1 }, a = i, (n = [{ key: "nextAutoLevel", get: function () { var e = this._nextAutoLevel, t = this._bwEstimator; if (!(-1 === e || t && t.canEstimate())) return e; var r = this._nextABRAutoLevel; return -1 !== e && (r = Math.min(e, r)), r }, set: function (e) { this._nextAutoLevel = e } }, { key: "_nextABRAutoLevel", get: function () { var e = this.hls, t = e.maxAutoLevel, r = e.levels, i = e.config, a = e.minAutoLevel, n = e.media, s = this.lastLoadedFragLevel, o = this.fragCurrent ? this.fragCurrent.duration : 0, l = n ? n.currentTime : 0, u = n && 0 !== n.playbackRate ? Math.abs(n.playbackRate) : 1, d = this._bwEstimator ? this._bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate, c = (Y.bufferInfo(n, l, i.maxBufferHole).end - l) / u, h = this._findBestLevel(s, o, d, a, t, c, i.abrBandWidthFactor, i.abrBandWidthUpFactor, r); if (0 <= h) return h; N.logger.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering"); var f, g = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay, p = i.abrBandWidthFactor, v = i.abrBandWidthUpFactor; return 0 != c || (f = this.bitrateTestDelay) && (g = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - f, N.logger.trace("bitrate test took " + Math.round(1e3 * f) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * g) + " ms"), p = v = 1), h = this._findBestLevel(s, o, d, a, t, c + g, p, v, r), Math.max(h, 0) } }]) && He(a.prototype, n), s && He(a, s), i }(u); var We = X(), qe = function (t) { var e, r; function i(e) { var o = t.call(this, e, M.default.MEDIA_ATTACHING, M.default.MEDIA_DETACHING, M.default.MANIFEST_PARSED, M.default.BUFFER_RESET, M.default.BUFFER_APPENDING, M.default.BUFFER_CODECS, M.default.BUFFER_EOS, M.default.BUFFER_FLUSHING, M.default.LEVEL_PTS_UPDATED, M.default.LEVEL_UPDATED) || this; return o._msDuration = null, o._levelDuration = null, o._levelTargetDuration = 10, o._live = null, o._objectUrl = null, o._needsFlush = !1, o._needsEos = !1, o.config = void 0, o.audioTimestampOffset = void 0, o.bufferCodecEventsExpected = 0, o._bufferCodecEventsTotal = 0, o.media = null, o.mediaSource = null, o.segments = [], o.parent = void 0, o.appending = !1, o.appended = 0, o.appendError = 0, o.flushBufferCounter = 0, o.tracks = {}, o.pendingTracks = {}, o.sourceBuffer = {}, o.flushRange = [], o._onMediaSourceOpen = function () { N.logger.log("media source opened"), o.hls.trigger(M.default.MEDIA_ATTACHED, { media: o.media }); var e = o.mediaSource; e && e.removeEventListener("sourceopen", o._onMediaSourceOpen), o.checkPendingTracks() }, o._onMediaSourceClose = function () { N.logger.log("media source closed") }, o._onMediaSourceEnded = function () { N.logger.log("media source ended") }, o._onSBUpdateEnd = function () { var e; o.audioTimestampOffset && o.sourceBuffer.audio && (e = o.sourceBuffer.audio, N.logger.warn("change mpeg audio timestamp offset from " + e.timestampOffset + " to " + o.audioTimestampOffset), e.timestampOffset = o.audioTimestampOffset, delete o.audioTimestampOffset), o._needsFlush && o.doFlush(), o._needsEos && o.checkEos(), o.appending = !1; var r = o.parent, t = o.segments.reduce(function (e, t) { return t.parent === r ? e + 1 : e }, 0), i = {}, a = o.sourceBuffer; for (var n in a) { var s = a[n]; if (!s) throw Error("handling source buffer update end error: source buffer for " + n + " uninitilized and unable to update buffered TimeRanges."); i[n] = s.buffered } o.hls.trigger(M.default.BUFFER_APPENDED, { parent: r, pending: t, timeRanges: i }), o._needsFlush || o.doAppending(), o.updateMediaElementDuration(), 0 === t && o.flushLiveBackBuffer() }, o._onSBUpdateError = function (e) { N.logger.error("sourceBuffer error:", e), o.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: !1 }) }, o.config = e.config, o } r = t, (e = i).prototype = Object.create(r.prototype), (e.prototype.constructor = e).__proto__ = r; var a = i.prototype; return a.destroy = function () { u.prototype.destroy.call(this) }, a.onLevelPtsUpdated = function (e) { var t = e.type, r = this.tracks.audio; if ("audio" === t && r && "audio/mpeg" === r.container) { var i = this.sourceBuffer.audio; if (!i) throw Error("Level PTS Updated and source buffer for audio uninitalized"); if (.1 < Math.abs(i.timestampOffset - e.start)) { var a = i.updating; try { i.abort() } catch (e) { N.logger.warn("can not abort audio buffer: " + e) } a ? this.audioTimestampOffset = e.start : (N.logger.warn("change mpeg audio timestamp offset from " + i.timestampOffset + " to " + e.start), i.timestampOffset = e.start) } } }, a.onManifestParsed = function (e) { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = e.altAudio ? 2 : 1, N.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected") }, a.onMediaAttaching = function (e) { var t, r = this.media = e.media; r && We && ((t = this.mediaSource = new We).addEventListener("sourceopen", this._onMediaSourceOpen), t.addEventListener("sourceended", this._onMediaSourceEnded), t.addEventListener("sourceclose", this._onMediaSourceClose), r.src = window.URL.createObjectURL(t), this._objectUrl = r.src) }, a.onMediaDetaching = function () { N.logger.log("media source detaching"); var e = this.mediaSource; if (e) { if ("open" === e.readyState) try { e.endOfStream() } catch (e) { N.logger.warn("onMediaDetaching:" + e.message + " while calling endOfStream") } e.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("sourceended", this._onMediaSourceEnded), e.removeEventListener("sourceclose", this._onMediaSourceClose), this.media && (this._objectUrl && window.URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute("src"), this.media.load()) : N.logger.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0 } this.hls.trigger(M.default.MEDIA_DETACHED) }, a.checkPendingTracks = function () { var e = this.bufferCodecEventsExpected, t = this.pendingTracks, r = Object.keys(t).length; (r && !e || 2 === r) && (this.createSourceBuffers(t), this.pendingTracks = {}, this.doAppending()) }, a.onBufferReset = function () { var e = this.sourceBuffer; for (var t in e) { var r = e[t]; try { r && (this.mediaSource && this.mediaSource.removeSourceBuffer(r), r.removeEventListener("updateend", this._onSBUpdateEnd), r.removeEventListener("error", this._onSBUpdateError)) } catch (e) { } } this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0 }, a.onBufferCodecs = function (t) { var r = this; Object.keys(this.sourceBuffer).length || (Object.keys(t).forEach(function (e) { r.pendingTracks[e] = t[e] }), this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks()) }, a.createSourceBuffers = function (e) { var t = this.sourceBuffer, r = this.mediaSource; if (!r) throw Error("createSourceBuffers called when mediaSource was null"); for (var i in e) if (!t[i]) { var a = e[i]; if (!a) throw Error("source buffer exists for track " + i + ", however track does not"); var n = a.levelCodec || a.codec, s = a.container + ";codecs=" + n; N.logger.log("creating sourceBuffer(" + s + ")"); try { var o = t[i] = r.addSourceBuffer(s); o.addEventListener("updateend", this._onSBUpdateEnd), o.addEventListener("error", this._onSBUpdateError), this.tracks[i] = { buffer: o, codec: n, id: a.id, container: a.container, levelCodec: a.levelCodec } } catch (e) { N.logger.error("error while trying to add sourceBuffer:" + e.message), this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: e, mimeType: s }) } } this.hls.trigger(M.default.BUFFER_CREATED, { tracks: this.tracks }) }, a.onBufferAppending = function (e) { this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending()) }, a.onBufferEos = function (e) { for (var t in this.sourceBuffer) { var r; e.type && e.type !== t || (r = this.sourceBuffer[t]) && !r.ended && (r.ended = !0, N.logger.log(t + " sourceBuffer now EOS")) } this.checkEos() }, a.checkEos = function () { var e = this.sourceBuffer, t = this.mediaSource; if (t && "open" === t.readyState) { for (var r in e) { var i = e[r]; if (i) { if (!i.ended) return; if (i.updating) return void (this._needsEos = !0) } } N.logger.log("all media data are available, signal endOfStream() to MediaSource and stop loading fragment"); try { t.endOfStream() } catch (e) { N.logger.warn("exception while calling mediaSource.endOfStream()") } this._needsEos = !1 } else this._needsEos = !1 }, a.onBufferFlushing = function (e) { e.type ? this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: e.type }) : (this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: "video" }), this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: "audio" })), this.flushBufferCounter = 0, this.doFlush() }, a.flushLiveBackBuffer = function () { if (this._live) { var e = this.config.liveBackBufferLength; if (isFinite(e) && !(e < 0)) if (this.media) for (var t = this.media.currentTime, r = this.sourceBuffer, i = Object.keys(r), a = t - Math.max(e, this._levelTargetDuration), n = i.length - 1; 0 <= n; n--) { var s, o = i[n], l = r[o]; !l || 0 < (s = l.buffered).length && a > s.start(0) && this.removeBufferRange(o, l, 0, a) && this.hls.trigger(M.default.LIVE_BACK_BUFFER_REACHED, { bufferEnd: a }) } else N.logger.error("flushLiveBackBuffer called without attaching media") } }, a.onLevelUpdated = function (e) { var t = e.details; 0 < t.fragments.length && (this._levelDuration = t.totalduration + t.fragments[0].start, this._levelTargetDuration = t.averagetargetduration || t.targetduration || 10, this._live = t.live, this.updateMediaElementDuration()) }, a.updateMediaElementDuration = function () { var e, t = this.config; if (null !== this._levelDuration && this.media && this.mediaSource && this.sourceBuffer && 0 !== this.media.readyState && "open" === this.mediaSource.readyState) { for (var r in this.sourceBuffer) { var i = this.sourceBuffer[r]; if (i && !0 === i.updating) return } e = this.media.duration, null === this._msDuration && (this._msDuration = this.mediaSource.duration), !0 === this._live && !0 === t.liveDurationInfinity ? (N.logger.log("Media Source duration is set to Infinity"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > e || !Object(F.isFiniteNumber)(e)) && (N.logger.log("Updating Media Source duration to " + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration) } }, a.doFlush = function () { for (; this.flushRange.length;) { var e = this.flushRange[0]; if (!this.flushBuffer(e.start, e.end, e.type)) return void (this._needsFlush = !0); this.flushRange.shift(), this.flushBufferCounter = 0 } if (0 === this.flushRange.length) { this._needsFlush = !1; var t = 0, r = this.sourceBuffer; try { for (var i in r) { var a = r[i]; a && (t += a.buffered.length) } } catch (e) { N.logger.error("error while accessing sourceBuffer.buffered") } this.appended = t, this.hls.trigger(M.default.BUFFER_FLUSHED) } }, a.doAppending = function () { var t = this.config, r = this.hls, i = this.segments, e = this.sourceBuffer; if (Object.keys(e).length) { if (!this.media || this.media.error) return this.segments = [], void N.logger.error("trying to append although a media error occured, flush segment and abort"); if (!this.appending) { var a = i.shift(); if (a) try { var n = e[a.type]; if (!n) return void this._onSBUpdateEnd(); if (n.updating) return void i.unshift(a); n.ended = !1, this.parent = a.parent, n.appendBuffer(a.data), this.appendError = 0, this.appended++, this.appending = !0 } catch (e) { N.logger.error("error while trying to append buffer:" + e.message), i.unshift(a); var s = { type: h.ErrorTypes.MEDIA_ERROR, parent: a.parent, details: "", fatal: !1 }; 22 === e.code ? (this.segments = [], s.details = h.ErrorDetails.BUFFER_FULL_ERROR) : (this.appendError++, s.details = h.ErrorDetails.BUFFER_APPEND_ERROR, this.appendError > t.appendErrorMaxRetry && (N.logger.log("fail " + t.appendErrorMaxRetry + " times to append segment in sourceBuffer"), this.segments = [], s.fatal = !0)), r.trigger(M.default.ERROR, s) } } } }, a.flushBuffer = function (e, t, r) { var i = this.sourceBuffer; if (!Object.keys(i).length) return !0; var a = "null"; if (this.media && (a = this.media.currentTime.toFixed(3)), N.logger.log("flushBuffer,pos/start/end: " + a + "/" + e + "/" + t), this.flushBufferCounter >= this.appended) return N.logger.warn("abort flushing too many retries"), !0; var n = i[r]; if (n) { if (n.ended = !1, n.updating) return N.logger.warn("cannot flush, sb updating in progress"), !1; if (this.removeBufferRange(r, n, e, t)) return this.flushBufferCounter++, !1 } return N.logger.log("buffer flushed"), !0 }, a.removeBufferRange = function (e, t, r, i) { try { for (var a = 0; a < t.buffered.length; a++) { var n = t.buffered.start(a), s = t.buffered.end(a), o = Math.max(n, r), l = Math.min(s, i); if (.5 < Math.min(l, s) - o) { var u = "null"; return this.media && (u = this.media.currentTime.toString()), N.logger.log("sb remove " + e + " [" + o + "," + l + "], of [" + n + "," + s + "], pos:" + u), t.remove(o, l), !0 } } } catch (e) { N.logger.warn("removeBufferRange failed", e) } return !1 }, i }(u); function ze(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var Xe = function (r) { var e, t; function a(e) { var t = r.call(this, e, M.default.FPS_DROP_LEVEL_CAPPING, M.default.MEDIA_ATTACHING, M.default.MANIFEST_PARSED, M.default.BUFFER_CODECS, M.default.MEDIA_DETACHING) || this; return t.autoLevelCapping = Number.POSITIVE_INFINITY, t.firstLevel = null, t.levels = [], t.media = null, t.restrictedLevels = [], t.timer = null, t } t = r, (e = a).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var i, n, s, o = a.prototype; return o.destroy = function () { this.hls.config.capLevelToPlayerSize && (this.media = null, this.stopCapping()) }, o.onFpsDropLevelCapping = function (e) { a.isLevelAllowed(e.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(e.droppedLevel) }, o.onMediaAttaching = function (e) { this.media = e.media instanceof window.HTMLVideoElement ? e.media : null }, o.onManifestParsed = function (e) { var t = this.hls; this.restrictedLevels = [], this.levels = e.levels, this.firstLevel = e.firstLevel, t.config.capLevelToPlayerSize && e.video && this.startCapping() }, o.onBufferCodecs = function (e) { this.hls.config.capLevelToPlayerSize && e.video && this.startCapping() }, o.onLevelsUpdated = function (e) { this.levels = e.levels }, o.onMediaDetaching = function () { this.stopCapping() }, o.detectPlayerSize = function () { var e, t; !this.media || (e = this.levels ? this.levels.length : 0) && ((t = this.hls).autoLevelCapping = this.getMaxLevel(e - 1), t.autoLevelCapping > this.autoLevelCapping && t.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping) }, o.getMaxLevel = function (r) { var i = this; if (!this.levels) return -1; var e = this.levels.filter(function (e, t) { return a.isLevelAllowed(t, i.restrictedLevels) && t <= r }); return a.getMaxLevelByMediaSize(e, this.mediaWidth, this.mediaHeight) }, o.startCapping = function () { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) }, o.stopCapping = function () { this.restrictedLevels = [], this.firstLevel = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer), this.timer = null) }, a.isLevelAllowed = function (e, t) { return void 0 === t && (t = []), -1 === t.indexOf(e) }, a.getMaxLevelByMediaSize = function (e, t, r) { if (!e || e && !e.length) return -1; for (var i, a, n = e.length - 1, s = 0; s < e.length; s += 1) { var o = e[s]; if ((o.width >= t || o.height >= r) && (i = o, !(a = e[s + 1]) || i.width !== a.width || i.height !== a.height)) { n = s; break } } return n }, i = a, s = [{ key: "contentScaleFactor", get: function () { var e = 1; try { e = window.devicePixelRatio } catch (e) { } return e } }], (n = [{ key: "mediaWidth", get: function () { var e, t = this.media; return t && (e = t.width || t.clientWidth || t.offsetWidth, e *= a.contentScaleFactor), e } }, { key: "mediaHeight", get: function () { var e, t = this.media; return t && (e = t.height || t.clientHeight || t.offsetHeight, e *= a.contentScaleFactor), e } }]) && ze(i.prototype, n), s && ze(i, s), a }(u); var Qe = window.performance, $e = function (t) { var e, r; function i(e) { return t.call(this, e, M.default.MEDIA_ATTACHING) || this } r = t, (e = i).prototype = Object.create(r.prototype), (e.prototype.constructor = e).__proto__ = r; var a = i.prototype; return a.destroy = function () { this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1 }, a.onMediaAttaching = function (e) { var t = this.hls.config; t.capLevelOnFPSDrop && ("function" == typeof (this.video = e.media instanceof window.HTMLVideoElement ? e.media : null).getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), t.fpsDroppedMonitoringPeriod)) }, a.checkFPS = function (e, t, r) { var i, a, n, s, o, l, u = Qe.now(); t && (this.lastTime && (i = u - this.lastTime, a = r - this.lastDroppedFrames, n = t - this.lastDecodedFrames, s = 1e3 * a / i, (o = this.hls).trigger(M.default.FPS_DROP, { currentDropped: a, currentDecoded: n, totalDroppedFrames: r }), 0 < s && a > o.config.fpsDroppedMonitoringThreshold * n && (l = o.currentLevel, N.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + l), 0 < l && (-1 === o.autoLevelCapping || o.autoLevelCapping >= l) && (--l, o.trigger(M.default.FPS_DROP_LEVEL_CAPPING, { level: l, droppedLevel: o.currentLevel }), o.autoLevelCapping = l, o.streamController.nextLevelSwitch()))), this.lastTime = u, this.lastDroppedFrames = r, this.lastDecodedFrames = t) }, a.checkFPSInterval = function () { var e, t = this.video; t && (this.isVideoPlaybackQualityAvailable ? (e = t.getVideoPlaybackQuality(), this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)) : this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount)) }, i }(u), Je = window, Ze = Je.performance, et = Je.XMLHttpRequest, tt = function () { function e(e) { e && e.xhrSetup && (this.xhrSetup = e.xhrSetup) } var t = e.prototype; return t.destroy = function () { this.abort(), this.loader = null }, t.abort = function () { var e = this.loader; e && 4 !== e.readyState && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null }, t.load = function (e, t, r) { this.context = e, this.config = t, this.callbacks = r, this.stats = { trequest: Ze.now(), retry: 0 }, this.retryDelay = t.retryDelay, this.loadInternal() }, t.loadInternal = function () { var t = this.context, r = this.loader = new et, e = this.stats; e.tfirst = 0, e.loaded = 0; var i = this.xhrSetup; try { if (i) try { i(r, t.url) } catch (e) { r.open("GET", t.url, !0), i(r, t.url) } r.readyState || r.open("GET", t.url, !0) } catch (e) { return void this.callbacks.onError({ code: r.status, text: e.message }, t, r) } t.rangeEnd && r.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), r.onreadystatechange = this.readystatechange.bind(this), r.onprogress = this.loadprogress.bind(this), r.responseType = t.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), r.send() }, t.readystatechange = function (e) { var t, r, i, a, n = e.currentTarget, s = n.readyState, o = this.stats, l = this.context, u = this.config; o.aborted || 2 <= s && (window.clearTimeout(this.requestTimeout), 0 === o.tfirst && (o.tfirst = Math.max(Ze.now(), o.trequest)), 4 === s ? 200 <= (t = n.status) && t < 300 ? (o.tload = Math.max(o.tfirst, Ze.now()), i = "arraybuffer" === l.responseType ? (r = n.response).byteLength : (r = n.responseText).length, o.loaded = o.total = i, a = { url: n.responseURL, data: r }, this.callbacks.onSuccess(a, o, l, n)) : o.retry >= u.maxRetry || 400 <= t && t < 499 ? (N.logger.error(t + " while loading " + l.url), this.callbacks.onError({ code: t, text: n.statusText }, l, n)) : (N.logger.warn(t + " while loading " + l.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, u.maxRetryDelay), o.retry++) : this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), u.timeout)) }, t.loadtimeout = function () { N.logger.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null) }, t.loadprogress = function (e) { var t = e.currentTarget, r = this.stats; r.loaded = e.loaded, e.lengthComputable && (r.total = e.total); var i = this.callbacks.onProgress; i && i(r, this.context, null, t) }, e }(); function rt(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var it = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.MANIFEST_LOADING, M.default.MANIFEST_PARSED, M.default.AUDIO_TRACK_LOADED, M.default.AUDIO_TRACK_SWITCHED, M.default.LEVEL_LOADED, M.default.ERROR) || this; return t._trackId = -1, t._selectDefaultTrack = !0, t.tracks = [], t.trackIdBlacklist = Object.create(null), t.audioGroupId = null, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = i.prototype; return o.onManifestLoading = function () { this.tracks = [], this._trackId = -1, this._selectDefaultTrack = !0 }, o.onManifestParsed = function (e) { var t = this.tracks = e.audioTracks || []; this.hls.trigger(M.default.AUDIO_TRACKS_UPDATED, { audioTracks: t }), this._selectAudioGroup(this.hls.nextLoadLevel) }, o.onAudioTrackLoaded = function (e) { var t; e.id >= this.tracks.length ? N.logger.warn("Invalid audio track id:", e.id) : (N.logger.log("audioTrack " + e.id + " loaded"), this.tracks[e.id].details = e.details, e.details.live && !this.hasInterval() && (t = 1e3 * e.details.targetduration, this.setInterval(t)), !e.details.live && this.hasInterval() && this.clearInterval()) }, o.onAudioTrackSwitched = function (e) { var t = this.tracks[e.id].groupId; t && this.audioGroupId !== t && (this.audioGroupId = t) }, o.onLevelLoaded = function (e) { this._selectAudioGroup(e.level) }, o.onError = function (e) { e.type === h.ErrorTypes.NETWORK_ERROR && (e.fatal && this.clearInterval(), e.details === h.ErrorDetails.AUDIO_TRACK_LOAD_ERROR && (N.logger.warn("Network failure on audio-track id:", e.context.id), this._handleLoadError())) }, o._setAudioTrack = function (e) { var t, r, i, a; this._trackId === e && this.tracks[this._trackId].details ? N.logger.debug("Same id as current audio-track passed, and track details available -> no-op") : e < 0 || e >= this.tracks.length ? N.logger.warn("Invalid id passed to audio-track controller") : (t = this.tracks[e], N.logger.log("Now switching to audio-track index " + e), this.clearInterval(), this._trackId = e, r = t.url, i = t.type, a = t.id, this.hls.trigger(M.default.AUDIO_TRACK_SWITCHING, { id: a, type: i, url: r }), this._loadTrackDetailsIfNeeded(t)) }, o.doTick = function () { this._updateTrack(this._trackId) }, o._selectAudioGroup = function (e) { var t, r = this.hls.levels[e]; r && r.audioGroupIds && (t = r.audioGroupIds[r.urlId], this.audioGroupId !== t && (this.audioGroupId = t, this._selectInitialAudioTrack())) }, o._selectInitialAudioTrack = function () { var e, t, r, i, a, n = this, s = this.tracks; s.length && (e = this.tracks[this._trackId], t = null, e && (t = e.name), this._selectDefaultTrack && ((r = s.filter(function (e) { return e.default })).length ? s = r : N.logger.warn("No default audio tracks defined")), i = !1, (a = function () { s.forEach(function (e) { i || n.audioGroupId && e.groupId !== n.audioGroupId || t && t !== e.name || (n._setAudioTrack(e.id), i = !0) }) })(), i || (t = null, a()), i || (N.logger.error("No track found for running audio group-ID: " + this.audioGroupId), this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: h.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, fatal: !0 }))) }, o._needsTrackLoading = function (e) { var t = e.details, r = e.url; return !(t && !t.live) && !!r }, o._loadTrackDetailsIfNeeded = function (e) { var t, r; this._needsTrackLoading(e) && (t = e.url, r = e.id, N.logger.log("loading audio-track playlist for id: " + r), this.hls.trigger(M.default.AUDIO_TRACK_LOADING, { url: t, id: r })) }, o._updateTrack = function (e) { var t; e < 0 || e >= this.tracks.length || (this.clearInterval(), this._trackId = e, N.logger.log("trying to update audio-track " + e), t = this.tracks[e], this._loadTrackDetailsIfNeeded(t)) }, o._handleLoadError = function () { this.trackIdBlacklist[this._trackId] = !0; var e = this._trackId, t = this.tracks[e], r = t.name, i = t.language, a = t.groupId; N.logger.warn("Loading failed on audio track id: " + e + ", group-id: " + a + ', name/language: "' + r + '" / "' + i + '"'); for (var n = e, s = 0; s < this.tracks.length; s++) { if (!this.trackIdBlacklist[s]) if (this.tracks[s].name === r) { n = s; break } } n !== e ? (N.logger.log("Attempting audio-track fallback id:", n, "group-id:", this.tracks[n].groupId), this._setAudioTrack(n)) : N.logger.warn('No fallback audio-track found for name/language: "' + r + '" / "' + i + '"') }, a = i, (n = [{ key: "audioTracks", get: function () { return this.tracks } }, { key: "audioTrack", get: function () { return this._trackId }, set: function (e) { this._setAudioTrack(e), this._selectDefaultTrack = !1 } }]) && rt(a.prototype, n), s && rt(a, s), i }(pe); function at(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function nt() { return { decode: function (e) { if (!e) return ""; if ("string" != typeof e) throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } } var st = window.performance, ot = function (i) { var e, t; function r(e, t) { var r = i.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHING, M.default.AUDIO_TRACKS_UPDATED, M.default.AUDIO_TRACK_SWITCHING, M.default.AUDIO_TRACK_LOADED, M.default.KEY_LOADED, M.default.FRAG_LOADED, M.default.FRAG_PARSING_INIT_SEGMENT, M.default.FRAG_PARSING_DATA, M.default.FRAG_PARSED, M.default.ERROR, M.default.BUFFER_RESET, M.default.BUFFER_CREATED, M.default.BUFFER_APPENDED, M.default.BUFFER_FLUSHED, M.default.INIT_PTS_FOUND) || this; return r.fragmentTracker = t, r.config = e.config, r.audioCodecSwap = !1, r._state = ve, r.initPTS = [], r.waitingFragment = null, r.videoTrackCC = null, r } t = i, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = r.prototype; return o.onInitPtsFound = function (e) { var t = e.id, r = e.frag.cc, i = e.initPTS; "main" === t && (this.initPTS[r] = i, this.videoTrackCC = r, N.logger.log("InitPTS for cc: " + r + " found from video track: " + i), this.state === De && this.tick()) }, o.startLoad = function (e) { var t; this.tracks ? (t = this.lastCurrentTime, this.stopLoad(), this.setInterval(100), (this.fragLoadError = 0) < t && -1 === e ? (N.logger.log("audio:override startPosition with lastCurrentTime @" + t.toFixed(3)), this.state = ye) : (this.lastCurrentTime = this.startPosition ? this.startPosition : e, this.state = me), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick()) : (this.startPosition = e, this.state = ve) }, o.doTick = function () { var e, t, r, i, a, n = this.hls, s = n.config; switch (this.state) { case Le: case Ee: case ke: break; case me: this.state = _e, this.loadedmetadata = !1; break; case ye: var o = this.tracks; if (!o) break; if (!this.media && (this.startFragRequested || !s.startFragPrefetch)) break; if (this.loadedmetadata) e = this.media.currentTime; else if (void 0 === (e = this.nextLoadPosition)) break; var l = this.mediaBuffer ? this.mediaBuffer : this.media, u = this.videoBuffer ? this.videoBuffer : this.media, d = Y.bufferInfo(l, e, s.maxBufferHole), c = Y.bufferInfo(u, e, s.maxBufferHole), h = d.len, f = d.end, g = this.fragPrevious, p = Math.min(s.maxBufferLength, s.maxMaxBufferLength), v = Math.max(p, c.len), m = this.audioSwitch, y = this.trackId; if ((h < v || m) && y < o.length) { if (void 0 === (r = o[y].details)) { this.state = _e; break } if (!m && this._streamEnded(d, r)) return this.hls.trigger(M.default.BUFFER_EOS, { type: "audio" }), void (this.state = we); var E, T = r.fragments, b = T.length, S = T[0].start, _ = T[b - 1].start + T[b - 1].duration; if (m) if (r.live && !r.PTSKnown) N.logger.log("switching audiotrack, live stream, unknown PTS,load first fragment"), f = 0; else if (f = e, r.PTSKnown && e < S) { if (!(d.end > S || d.nextStart)) return; N.logger.log("alt audio track ahead of main track, seek to start of alt audio track"), this.media.currentTime = S + .05 } if (r.initSegment && !r.initSegment.data) E = r.initSegment; else if (f <= S) { if (E = T[0], null !== this.videoTrackCC && E.cc !== this.videoTrackCC && (i = T, a = this.videoTrackCC, E = V.search(i, function (e) { return e.cc < a ? 1 : e.cc > a ? -1 : 0 })), r.live && E.loadIdx && E.loadIdx === this.fragLoadIdx) { var R = d.nextStart ? d.nextStart : S; return N.logger.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (R + .05)), void (this.media.currentTime = R + .05) } } else { var A = s.maxFragLookUpTolerance, k = g ? T[g.sn - T[0].sn + 1] : void 0, w = function (e) { var t = Math.min(A, e.duration); return e.start + e.duration - t <= f ? 1 : e.start - t > f && e.start ? -1 : 0 }, L = f < _ ? (_ - A < f && (A = 0), k && !w(k) ? k : V.search(T, w)) : T[b - 1]; L && (S = (E = L).start, g && E.level === g.level && E.sn === g.sn && (E.sn < r.endSN ? (E = T[E.sn + 1 - r.startSN], N.logger.log("SN just loaded, load next one: " + E.sn)) : E = null)) } E && (E.encrypted ? (N.logger.log("Loading key for " + E.sn + " of [" + r.startSN + " ," + r.endSN + "],track " + y), this.state = Te, n.trigger(M.default.KEY_LOADING, { frag: E })) : (N.logger.log("Loading " + E.sn + ", cc: " + E.cc + " of [" + r.startSN + " ," + r.endSN + "],track " + y + ", currentTime:" + e + ",bufferEnd:" + f.toFixed(3)), this.fragCurrent = E, !m && this.fragmentTracker.getState(E) !== B || ("initSegment" !== E.sn && (this.startFragRequested = !0), Object(F.isFiniteNumber)(E.sn) && (this.nextLoadPosition = E.start + E.duration), n.trigger(M.default.FRAG_LOADING, { frag: E }), this.state = be))) } break; case _e: (t = this.tracks[this.trackId]) && t.details && (this.state = ye); break; case Se: var D = st.now(), O = this.retryDate, C = (l = this.media) && l.seeking; (!O || O <= D || C) && (N.logger.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = ye); break; case De: var I = this.videoTrackCC; if (void 0 === this.initPTS[I]) break; var x, P = this.waitingFragment; P ? I !== (x = P.frag.cc) ? (t = this.tracks[this.trackId]).details && t.details.live && (N.logger.warn("Waiting fragment CC (" + x + ") does not match video track CC (" + I + ")"), this.waitingFragment = null, this.state = ye) : (this.state = be, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null) : this.state = ye } }, o.onMediaAttached = function (e) { var t = this.media = this.mediaBuffer = e.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener("seeking", this.onvseeking), t.addEventListener("ended", this.onvended); var r = this.config; this.tracks && r.autoStartLoad && this.startLoad(r.startPosition) }, o.onMediaDetaching = function () { var e = this.media; e && e.ended && (N.logger.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() }, o.onAudioTracksUpdated = function (e) { N.logger.log("audio tracks updated"), this.tracks = e.audioTracks }, o.onAudioTrackSwitching = function (e) { var t = !!e.url; this.trackId = e.id, this.fragCurrent = null, this.state = Ee, this.waitingFragment = null, t ? this.setInterval(100) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), t && (this.audioSwitch = !0, this.state = ye), this.tick() }, o.onAudioTrackLoaded = function (e) { var t, r, i = e.details, a = e.id, n = this.tracks[a], s = i.totalduration, o = 0; N.logger.log("track " + a + " loaded [" + i.startSN + "," + i.endSN + "],duration:" + s), i.live ? (t = n.details) && 0 < i.fragments.length ? (ae(t, i), o = i.fragments[0].start, i.PTSKnown ? N.logger.log("live audio playlist sliding:" + o.toFixed(3)) : N.logger.log("live audio playlist - outdated PTS, unknown sliding")) : (i.PTSKnown = !1, N.logger.log("live audio playlist - first load, unknown sliding")) : i.PTSKnown = !1, n.details = i, this.startFragRequested || (-1 === this.startPosition && (r = i.startTimeOffset, Object(F.isFiniteNumber)(r) ? (N.logger.log("start time offset found in playlist, adjust startPosition to " + r), this.startPosition = r) : i.live ? (this.startPosition = this.computeLivePosition(o, i), N.logger.log("compute startPosition for audio-track to " + this.startPosition)) : this.startPosition = 0), this.nextLoadPosition = this.startPosition), this.state === _e && (this.state = ye), this.tick() }, o.onKeyLoaded = function () { this.state === Te && (this.state = ye, this.tick()) }, o.onFragLoaded = function (e) { var t, r, i, a, n, s, o, l, u, d, c = this.fragCurrent, h = e.frag; this.state === be && c && "audio" === h.type && h.level === c.level && h.sn === c.sn && (i = (r = (t = this.tracks[this.trackId]).details).totalduration, a = c.level, n = c.sn, s = c.cc, o = this.config.defaultAudioCodec || t.audioCodec || "mp4a.40.2", l = this.stats = e.stats, "initSegment" === n ? (this.state = ye, l.tparsed = l.tbuffered = st.now(), r.initSegment.data = e.payload, this.hls.trigger(M.default.FRAG_BUFFERED, { stats: l, frag: c, id: "audio" }), this.tick()) : (this.state = Re, this.appended = !1, this.demuxer || (this.demuxer = new ee(this.hls, "audio")), u = this.initPTS[s], d = r.initSegment ? r.initSegment.data : [], r.initSegment || void 0 !== u ? (this.pendingBuffering = !0, N.logger.log("Demuxing " + n + " of [" + r.startSN + " ," + r.endSN + "],track " + a), this.demuxer.push(e.payload, d, o, null, c, i, !1, u)) : (N.logger.log("unknown video PTS for continuity counter " + s + ", waiting for video PTS before demuxing audio frag " + n + " of [" + r.startSN + " ," + r.endSN + "],track " + a), this.waitingFragment = e, this.state = De))), this.fragLoadError = 0 }, o.onFragParsingInitSegment = function (e) { var t, r, i, a, n = this.fragCurrent, s = e.frag; n && "audio" === e.id && s.sn === n.sn && s.level === n.level && this.state === Re && ((t = e.tracks).video && delete t.video, (r = t.audio) && (r.levelCodec = r.codec, r.id = e.id, this.hls.trigger(M.default.BUFFER_CODECS, t), N.logger.log("audio track:audio,container:" + r.container + ",codecs[level/parsed]=[" + r.levelCodec + "/" + r.codec + "]"), (i = r.initSegment) && (a = { type: "audio", data: i, parent: "audio", content: "initSegment" }, this.audioSwitch ? this.pendingData = [a] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(M.default.BUFFER_APPENDING, a))), this.tick())) }, o.onFragParsingData = function (t) { var r = this, e = this.fragCurrent, i = t.frag; if (e && "audio" === t.id && "audio" === t.type && i.sn === e.sn && i.level === e.level && this.state === Re) { var a = this.trackId, n = this.tracks[a], s = this.hls; Object(F.isFiniteNumber)(t.endPTS) || (t.endPTS = t.startPTS + e.duration, t.endDTS = t.startDTS + e.duration), e.addElementaryStream(f.AUDIO), N.logger.log("parsed " + t.type + ",PTS:[" + t.startPTS.toFixed(3) + "," + t.endPTS.toFixed(3) + "],DTS:[" + t.startDTS.toFixed(3) + "/" + t.endDTS.toFixed(3) + "],nb:" + t.nb), ie(n.details, e, t.startPTS, t.endPTS); var o, l = this.audioSwitch, u = this.media, d = !1; l && (u && u.readyState ? (o = u.currentTime, N.logger.log("switching audio track : currentTime:" + o), o >= t.startPTS && (N.logger.log("switching audio track : flushing all audio"), this.state = ke, s.trigger(M.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), d = !0, this.audioSwitch = !1, s.trigger(M.default.AUDIO_TRACK_SWITCHED, { id: a }))) : (this.audioSwitch = !1, s.trigger(M.default.AUDIO_TRACK_SWITCHED, { id: a }))); var c = this.pendingData; if (!c) return N.logger.warn("Apparently attempt to enqueue media payload without codec initialization data upfront"), void s.trigger(M.default.ERROR, { type: h.ErrorTypes.MEDIA_ERROR, details: null, fatal: !0 }); this.audioSwitch || ([t.data1, t.data2].forEach(function (e) { e && e.length && c.push({ type: t.type, data: e, parent: "audio", content: "data" }) }), !d && c.length && (c.forEach(function (e) { r.state === Re && (r.pendingBuffering = !0, r.hls.trigger(M.default.BUFFER_APPENDING, e)) }), this.pendingData = [], this.appended = !0)), this.tick() } }, o.onFragParsed = function (e) { var t = this.fragCurrent, r = e.frag; t && "audio" === e.id && r.sn === t.sn && r.level === t.level && this.state === Re && (this.stats.tparsed = st.now(), this.state = Ae, this._checkAppendedParsed()) }, o.onBufferReset = function () { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1 }, o.onBufferCreated = function (e) { var t = e.tracks.audio; t && (this.mediaBuffer = t.buffer, this.loadedmetadata = !0), e.tracks.video && (this.videoBuffer = e.tracks.video.buffer) }, o.onBufferAppended = function (e) { var t; "audio" === e.parent && ((t = this.state) !== Re && t !== Ae || (this.pendingBuffering = 0 < e.pending, this._checkAppendedParsed())) }, o._checkAppendedParsed = function () { var e, t, r, i; this.state !== Ae || this.appended && this.pendingBuffering || (e = this.fragCurrent, t = this.stats, r = this.hls, e && (this.fragPrevious = e, t.tbuffered = st.now(), r.trigger(M.default.FRAG_BUFFERED, { stats: t, frag: e, id: "audio" }), (i = this.mediaBuffer ? this.mediaBuffer : this.media) && N.logger.log("audio buffered : " + oe.toString(i.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, r.trigger(M.default.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = ye), this.tick()) }, o.onError = function (e) { var t, r, i, a = e.frag; if (!a || "audio" === a.type) switch (e.details) { case h.ErrorDetails.FRAG_LOAD_ERROR: case h.ErrorDetails.FRAG_LOAD_TIMEOUT: var n, s, o, l = e.frag; if (l && "audio" !== l.type) break; e.fatal || ((n = this.fragLoadError) ? n++ : n = 1, n <= (s = this.config).fragLoadingMaxRetry ? (this.fragLoadError = n, o = Math.min(Math.pow(2, n - 1) * s.fragLoadingRetryDelay, s.fragLoadingMaxRetryTimeout), N.logger.warn("AudioStreamController: frag loading failed, retry in " + o + " ms"), this.retryDate = st.now() + o, this.state = Se) : (N.logger.error("AudioStreamController: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.state = Le)); break; case h.ErrorDetails.AUDIO_TRACK_LOAD_ERROR: case h.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT: case h.ErrorDetails.KEY_LOAD_ERROR: case h.ErrorDetails.KEY_LOAD_TIMEOUT: this.state !== Le && (this.state = e.fatal ? Le : ye, N.logger.warn("AudioStreamController: " + e.details + " while loading frag, now switching to " + this.state + " state ...")); break; case h.ErrorDetails.BUFFER_FULL_ERROR: "audio" !== e.parent || this.state !== Re && this.state !== Ae || (t = this.mediaBuffer, r = this.media.currentTime, t && Y.isBuffered(t, r) && Y.isBuffered(t, r + .5) ? ((i = this.config).maxMaxBufferLength >= i.maxBufferLength && (i.maxMaxBufferLength /= 2, N.logger.warn("AudioStreamController: reduce max buffer length to " + i.maxMaxBufferLength + "s")), this.state = ye) : (N.logger.warn("AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, this.state = ke, this.hls.trigger(M.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }))) } }, o.onBufferFlushed = function () { var t = this, e = this.pendingData; e && e.length ? (N.logger.log("AudioStreamController: appending pending audio data after buffer flushed"), e.forEach(function (e) { t.hls.trigger(M.default.BUFFER_APPENDING, e) }), this.appended = !0, this.pendingData = [], this.state = Ae) : (this.state = ye, this.fragPrevious = null, this.tick()) }, a = r, (n = [{ key: "state", set: function (e) { var t; this.state !== e && (t = this.state, this._state = e, N.logger.log("audio stream:" + t + "->" + e)) }, get: function () { return this._state } }]) && at(a.prototype, n), s && at(a, s), r }(Ce), lt = function () { if ("undefined" != typeof window && window.VTTCue) return window.VTTCue; var E = { "": !0, lr: !0, rl: !0 }, t = { start: !0, middle: !0, end: !0, left: !0, right: !0 }; function T(e) { return "string" == typeof e && (!!t[e.toLowerCase()] && e.toLowerCase()) } function b(e) { for (var t = 1; t < arguments.length; t++) { var r = arguments[t]; for (var i in r) e[i] = r[i] } return e } function e(e, t, r) { var i = this, a = { enumerable: !0 }; i.hasBeenReset = !1; var n = "", s = !1, o = e, l = t, u = r, d = null, c = "", h = !0, f = "auto", g = "start", p = 50, v = "middle", m = 50, y = "middle"; Object.defineProperty(i, "id", b({}, a, { get: function () { return n }, set: function (e) { n = "" + e } })), Object.defineProperty(i, "pauseOnExit", b({}, a, { get: function () { return s }, set: function (e) { s = !!e } })), Object.defineProperty(i, "startTime", b({}, a, { get: function () { return o }, set: function (e) { if ("number" != typeof e) throw new TypeError("Start time must be set to a number."); o = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "endTime", b({}, a, { get: function () { return l }, set: function (e) { if ("number" != typeof e) throw new TypeError("End time must be set to a number."); l = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "text", b({}, a, { get: function () { return u }, set: function (e) { u = "" + e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "region", b({}, a, { get: function () { return d }, set: function (e) { d = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "vertical", b({}, a, { get: function () { return c }, set: function (e) { var t, r = "string" == typeof (t = e) && !!E[t.toLowerCase()] && t.toLowerCase(); if (!1 === r) throw new SyntaxError("An invalid or illegal string was specified."); c = r, this.hasBeenReset = !0 } })), Object.defineProperty(i, "snapToLines", b({}, a, { get: function () { return h }, set: function (e) { h = !!e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "line", b({}, a, { get: function () { return f }, set: function (e) { if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified."); f = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "lineAlign", b({}, a, { get: function () { return g }, set: function (e) { var t = T(e); if (!t) throw new SyntaxError("An invalid or illegal string was specified."); g = t, this.hasBeenReset = !0 } })), Object.defineProperty(i, "position", b({}, a, { get: function () { return p }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Position must be between 0 and 100."); p = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "positionAlign", b({}, a, { get: function () { return v }, set: function (e) { var t = T(e); if (!t) throw new SyntaxError("An invalid or illegal string was specified."); v = t, this.hasBeenReset = !0 } })), Object.defineProperty(i, "size", b({}, a, { get: function () { return m }, set: function (e) { if (e < 0 || 100 < e) throw new Error("Size must be between 0 and 100."); m = e, this.hasBeenReset = !0 } })), Object.defineProperty(i, "align", b({}, a, { get: function () { return y }, set: function (e) { var t = T(e); if (!t) throw new SyntaxError("An invalid or illegal string was specified."); y = t, this.hasBeenReset = !0 } })), i.displayState = void 0 } return e.prototype.getCueAsHTML = function () { return window.WebVTT.convertCueToDOMTree(window, this.text) }, e }(); function ut() { this.window = window, this.state = "INITIAL", this.buffer = "", this.decoder = new nt, this.regionList = [] } function dt() { this.values = Object.create(null) } function ct(e, t, r, i) { var a, n = i ? e.split(i) : [e]; for (var s in n) { "string" == typeof n[s] && (2 === (a = n[s].split(r)).length && t(a[0], a[1])) } } dt.prototype = { set: function (e, t) { this.get(e) || "" === t || (this.values[e] = t) }, get: function (e, t, r) { return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t }, has: function (e) { return e in this.values }, alt: function (e, t, r) { for (var i = 0; i < r.length; ++i)if (t === r[i]) { this.set(e, t); break } }, integer: function (e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) }, percent: function (e, t) { return !!(t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && 0 <= (t = parseFloat(t)) && t <= 100) && (this.set(e, t), !0) } }; var ht = new lt(0, 0, 0), ft = "middle" === ht.align ? "middle" : "center"; function gt(i, e, s) { var a = i; function t() { var e, t = (e = i.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/)) ? e[3] ? r(e[1], e[2], e[3].replace(":", ""), e[4]) : 59 < e[1] ? r(e[1], e[2], 0, e[4]) : r(0, e[1], e[2], e[4]) : null; function r(e, t, r, i) { return 3600 * (0 | e) + 60 * (0 | t) + (0 | r) + (0 | i) / 1e3 } if (null === t) throw new Error("Malformed timestamp: " + a); return i = i.replace(/^[^\sa-zA-Z-]+/, ""), t } function r() { i = i.replace(/^\s+/, "") } if (r(), e.startTime = t(), r(), "--\x3e" !== i.substr(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + a); i = i.substr(3), r(), e.endTime = t(), r(), function (e, t) { var n = new dt; ct(e, function (e, t) { switch (e) { case "region": for (var r = s.length - 1; 0 <= r; r--)if (s[r].id === t) { n.set(e, s[r].region); break } break; case "vertical": n.alt(e, t, ["rl", "lr"]); break; case "line": var i = t.split(","), a = i[0]; n.integer(e, a), n.percent(e, a) && n.set("snapToLines", !1), n.alt(e, a, ["auto"]), 2 === i.length && n.alt("lineAlign", i[1], ["start", ft, "end"]); break; case "position": i = t.split(","), n.percent(e, i[0]), 2 === i.length && n.alt("positionAlign", i[1], ["start", ft, "end", "line-left", "line-right", "auto"]); break; case "size": n.percent(e, t); break; case "align": n.alt(e, t, ["start", ft, "end", "left", "right"]) } }, /:/, /\s/), t.region = n.get("region", null), t.vertical = n.get("vertical", ""); var r = n.get("line", "auto"); "auto" === r && -1 === ht.line && (r = -1), t.line = r, t.lineAlign = n.get("lineAlign", "start"), t.snapToLines = n.get("snapToLines", !0), t.size = n.get("size", 100), t.align = n.get("align", ft); var i = n.get("position", "auto"); "auto" === i && 50 === ht.position && (i = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = i }(i, e) } function pt(e) { return e.replace(/<br(?: \/)?>/gi, "\n") } ut.prototype = { parse: function (e) { var t, i = this; function r() { for (var e = 0, t = pt(t = i.buffer); e < t.length && "\r" !== t[e] && "\n" !== t[e];)++e; var r = t.substr(0, e); return "\r" === t[e] && ++e, "\n" === t[e] && ++e, i.buffer = t.substr(e), r } e && (i.buffer += i.decoder.decode(e, { stream: !0 })); try { if ("INITIAL" === i.state) { if (!/\r\n|\n/.test(i.buffer)) return this; var a = (t = r()).match(/^(ËåÇÁ¶ÑÈ©¥)?WEBVTT([ \t].*)?$/); if (!a || !a[0]) throw new Error("Malformed WebVTT signature."); i.state = "HEADER" } for (var n = !1; i.buffer;) { if (!/\r\n|\n/.test(i.buffer)) return this; switch (n ? n = !1 : t = r(), i.state) { case "HEADER": /:/.test(t) ? ct(t, function (e, t) { e }, /:/) : t || (i.state = "ID"); continue; case "NOTE": t || (i.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(t)) { i.state = "NOTE"; break } if (!t) continue; if (i.cue = new lt(0, 0, ""), i.state = "CUE", -1 === t.indexOf("--\x3e")) { i.cue.id = t; continue } case "CUE": try { gt(t, i.cue, i.regionList) } catch (e) { i.cue = null, i.state = "BADCUE"; continue } i.state = "CUETEXT"; continue; case "CUETEXT": var s = -1 !== t.indexOf("--\x3e"); if (!t || s && (n = !0)) { i.oncue && i.oncue(i.cue), i.cue = null, i.state = "ID"; continue } i.cue.text && (i.cue.text += "\n"), i.cue.text += t; continue; case "BADCUE": t || (i.state = "ID"); continue } } } catch (e) { "CUETEXT" === i.state && i.cue && i.oncue && i.oncue(i.cue), i.cue = null, i.state = "INITIAL" === i.state ? "BADWEBVTT" : "BADCUE" } return this }, flush: function () { try { if (this.buffer += this.decoder.decode(), !this.cue && "HEADER" !== this.state || (this.buffer += "\n\n", this.parse()), "INITIAL" === this.state) throw new Error("Malformed WebVTT signature.") } catch (e) { throw e } return this.onflush && this.onflush(), this } }; var vt = ut; function mt(e, t, r, i) { for (var a, n, s, o, l, u = window.VTTCue || TextTrackCue, d = 0; d < i.rows.length; d++)if (s = !0, o = 0, l = "", !(a = i.rows[d]).isEmpty()) { for (var c = 0; c < a.chars.length; c++)a.chars[c].uchar.match(/\s/) && s ? o++ : (l += a.chars[c].uchar, s = !1); (a.cueStartTime = t) === r && (r += 1e-4), n = new u(t, r, pt(l.trim())), 16 <= o ? o-- : o++, navigator.userAgent.match(/Firefox\//) ? n.line = d + 1 : n.line = 7 < d ? d - 2 : d + 1, n.align = "left", n.position = Math.max(0, Math.min(100, o / 32 * 100)), e.addCue(n) } } function yt(e) { var t = e; return Tt.hasOwnProperty(e) && (t = Tt[e]), String.fromCharCode(t) } var Et, Tt = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, bt = 100, St = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, _t = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, Rt = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, At = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, kt = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"]; (Et = {})[Et.ERROR = 0] = "ERROR", Et[Et.TEXT = 1] = "TEXT", Et[Et.WARNING = 2] = "WARNING", Et[Et.INFO = 2] = "INFO", Et[Et.DEBUG = 3] = "DEBUG", Et[Et.DATA = 3] = "DATA"; function wt(e) { for (var t = [], r = 0; r < e.length; r++)t.push(e[r].toString(16)); return t } function Lt(e, t, r) { return e.substr(r || 0, t.length) === t } function Dt(e) { for (var t = 5381, r = e.length; r;)t = 33 * t ^ e.charCodeAt(--r); return (t >>> 0).toString() } var Ot = { verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 }, time: null, verboseLevel: 0, setTime: function (e) { this.time = e }, log: function (e) { this.verboseFilter[e]; this.verboseLevel } }, Ct = function () { function e(e, t, r, i, a) { this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = r || !1, this.background = i || "black", this.flash = a || !1 } var t = e.prototype; return t.reset = function () { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 }, t.setStyles = function (e) { for (var t = ["foreground", "underline", "italics", "background", "flash"], r = 0; r < t.length; r++) { var i = t[r]; e.hasOwnProperty(i) && (this[i] = e[i]) } }, t.isDefault = function () { return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash }, t.equals = function (e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash }, t.copy = function (e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash }, t.toString = function () { return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash }, e }(), It = function () { function e(e, t, r, i, a, n) { this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new Ct(t, r, i, a, n) } var t = e.prototype; return t.reset = function () { this.uchar = " ", this.penState.reset() }, t.setChar = function (e, t) { this.uchar = e, this.penState.copy(t) }, t.setPenState = function (e) { this.penState.copy(e) }, t.equals = function (e) { return this.uchar === e.uchar && this.penState.equals(e.penState) }, t.copy = function (e) { this.uchar = e.uchar, this.penState.copy(e.penState) }, t.isEmpty = function () { return " " === this.uchar && this.penState.isDefault() }, e }(), xt = function () { function e() { this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.chars = []; for (var e = 0; e < bt; e++)this.chars.push(new It); this.pos = 0, this.currPenState = new Ct } var t = e.prototype; return t.equals = function (e) { for (var t = !0, r = 0; r < bt; r++)if (!this.chars[r].equals(e.chars[r])) { t = !1; break } return t }, t.copy = function (e) { for (var t = 0; t < bt; t++)this.chars[t].copy(e.chars[t]) }, t.isEmpty = function () { for (var e = !0, t = 0; t < bt; t++)if (!this.chars[t].isEmpty()) { e = !1; break } return e }, t.setCursor = function (e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (Ot.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > bt && (Ot.log("ERROR", "Too large cursor position " + this.pos), this.pos = bt) }, t.moveCursor = function (e) { var t = this.pos + e; if (1 < e) for (var r = this.pos + 1; r < t + 1; r++)this.chars[r].setPenState(this.currPenState); this.setCursor(t) }, t.backSpace = function () { this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState) }, t.insertChar = function (e) { 144 <= e && this.backSpace(); var t = yt(e); this.pos >= bt ? Ot.log("ERROR", "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1)) }, t.clearFromPos = function (e) { for (var t = e; t < bt; t++)this.chars[t].reset() }, t.clear = function () { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() }, t.clearToEndOfRow = function () { this.clearFromPos(this.pos) }, t.getTextString = function () { for (var e = [], t = !0, r = 0; r < bt; r++) { var i = this.chars[r].uchar; " " !== i && (t = !1), e.push(i) } return t ? "" : e.join("") }, t.setPenStyles = function (e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState) }, e }(), Pt = function () { function e() { this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.rows = []; for (var e = 0; e < 15; e++)this.rows.push(new xt); this.currRow = 14, this.nrRollUpRows = null, this.reset() } var t = e.prototype; return t.reset = function () { for (var e = 0; e < 15; e++)this.rows[e].clear(); this.currRow = 14 }, t.equals = function (e) { for (var t = !0, r = 0; r < 15; r++)if (!this.rows[r].equals(e.rows[r])) { t = !1; break } return t }, t.copy = function (e) { for (var t = 0; t < 15; t++)this.rows[t].copy(e.rows[t]) }, t.isEmpty = function () { for (var e = !0, t = 0; t < 15; t++)if (!this.rows[t].isEmpty()) { e = !1; break } return e }, t.backSpace = function () { this.rows[this.currRow].backSpace() }, t.clearToEndOfRow = function () { this.rows[this.currRow].clearToEndOfRow() }, t.insertChar = function (e) { this.rows[this.currRow].insertChar(e) }, t.setPen = function (e) { this.rows[this.currRow].setPenStyles(e) }, t.moveCursor = function (e) { this.rows[this.currRow].moveCursor(e) }, t.setCursor = function (e) { Ot.log("INFO", "setCursor: " + e), this.rows[this.currRow].setCursor(e) }, t.setPAC = function (e) { Ot.log("INFO", "pacData = " + JSON.stringify(e)); var t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (var r = 0; r < 15; r++)this.rows[r].clear(); var i = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen; if (a) { var n = a.rows[i].cueStartTime; if (n && Ot.time && n < Ot.time) for (var s = 0; s < this.nrRollUpRows; s++)this.rows[t - this.nrRollUpRows + s + 1].copy(a.rows[i + s]) } } this.currRow = t; var o, l, u = this.rows[this.currRow]; null !== e.indent && (o = e.indent, l = Math.max(o - 1, 0), u.setCursor(e.indent), e.color = u.chars[l].penState.foreground); var d = { foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1 }; this.setPen(d) }, t.setBkgData = function (e) { Ot.log("INFO", "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32) }, t.setRollUpRows = function (e) { this.nrRollUpRows = e }, t.rollUp = function () { var e, t; null !== this.nrRollUpRows ? (Ot.log("TEXT", this.getDisplayText()), e = this.currRow + 1 - this.nrRollUpRows, (t = this.rows.splice(e, 1)[0]).clear(), this.rows.splice(this.currRow, 0, t), Ot.log("INFO", "Rolling up")) : Ot.log("DEBUG", "roll_up but nrRollUpRows not set yet") }, t.getDisplayText = function (e) { e = e || !1; for (var t, r = [], i = "", a = 0; a < 15; a++) { var n = this.rows[a].getTextString(); n && (t = a + 1, e ? r.push("Row " + t + ": '" + n + "'") : r.push(n.trim())) } return 0 < r.length && (i = e ? "[" + r.join(" | ") + "]" : r.join("\n")), i }, t.getTextAndFormat = function () { return this.rows }, e }(), Ft = function () { function e(e, t) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.lastCueEndTime = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Pt, this.nonDisplayedMemory = new Pt, this.lastOutputScreen = new Pt, this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null } var t = e.prototype; return t.reset = function () { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null }, t.getHandler = function () { return this.outputFilter }, t.setHandler = function (e) { this.outputFilter = e }, t.setPAC = function (e) { this.writeScreen.setPAC(e) }, t.setBkgData = function (e) { this.writeScreen.setBkgData(e) }, t.setMode = function (e) { e !== this.mode && (this.mode = e, Ot.log("INFO", "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) }, t.insertChars = function (e) { for (var t = 0; t < e.length; t++)this.writeScreen.insertChar(e[t]); var r = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP"; Ot.log("INFO", r + ": " + this.writeScreen.getDisplayText(!0)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (Ot.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) }, t.ccRCL = function () { Ot.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON") }, t.ccBS = function () { Ot.log("INFO", "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()) }, t.ccAOF = function () { }, t.ccAON = function () { }, t.ccDER = function () { Ot.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() }, t.ccRU = function (e) { Ot.log("INFO", "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e) }, t.ccFON = function () { Ot.log("INFO", "FON - Flash On"), this.writeScreen.setPen({ flash: !0 }) }, t.ccRDC = function () { Ot.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON") }, t.ccTR = function () { Ot.log("INFO", "TR"), this.setMode("MODE_TEXT") }, t.ccRTD = function () { Ot.log("INFO", "RTD"), this.setMode("MODE_TEXT") }, t.ccEDM = function () { Ot.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0) }, t.ccCR = function () { Ot.log("INFO", "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0) }, t.ccENM = function () { Ot.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset() }, t.ccEOC = function () { var e; Ot.log("INFO", "EOC - End Of Caption"), "MODE_POP-ON" === this.mode && (e = this.displayedMemory, this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, Ot.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText())), this.outputDataUpdate(!0) }, t.ccTO = function (e) { Ot.log("INFO", "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e) }, t.ccMIDROW = function (e) { var t, r = { flash: !1 }; r.underline = e % 2 == 1, r.italics = 46 <= e, r.italics ? r.foreground = "white" : (t = Math.floor(e / 2) - 16, r.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][t]), Ot.log("INFO", "MIDROW: " + JSON.stringify(r)), this.writeScreen.setPen(r) }, t.outputDataUpdate = function (e) { void 0 === e && (e = !1); var t = Ot.time; null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory)) }, t.cueSplitAtTime = function (e) { this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e)) }, e }(), Mt = function () { function e(e, t, r) { this.field = void 0, this.outputs = void 0, this.channels = void 0, this.currChNr = void 0, this.lastCmdA = void 0, this.lastCmdB = void 0, this.lastTime = void 0, this.dataCounters = void 0, this.field = e || 1, this.outputs = [t, r], this.channels = [new Ft(1, t), new Ft(2, r)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 } } var t = e.prototype; return t.getHandler = function (e) { return this.channels[e].getHandler() }, t.setHandler = function (e, t) { this.channels[e].setHandler(t) }, t.addData = function (e, t) { var r, i = !1; this.lastTime = e, Ot.setTime(e); for (var a = 0; a < t.length; a += 2) { var n = 127 & t[a], s = 127 & t[a + 1]; 0 != n || 0 != s ? (Ot.log("DATA", "[" + wt([t[a], t[a + 1]]) + "] -> (" + wt([n, s]) + ")"), (r = (r = (r = (r = this.parseCmd(n, s)) || this.parseMidrow(n, s)) || this.parsePAC(n, s)) || this.parseBackgroundAttributes(n, s)) || (i = this.parseChars(n, s)) && (this.currChNr && 0 <= this.currChNr ? this.channels[this.currChNr - 1].insertChars(i) : Ot.log("WARNING", "No channel found yet. TEXT-MODE?")), r ? this.dataCounters.cmd += 2 : i ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, Ot.log("WARNING", "Couldn't parse cleaned data " + wt([n, s]) + " orig: " + wt([t[a], t[a + 1]])))) : this.dataCounters.padding += 2 } }, t.parseCmd = function (e, t) { var r = null; if (!((20 === e || 28 === e) && 32 <= t && t <= 47) && !((23 === e || 31 === e) && 33 <= t && t <= 35)) return !1; if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, Ot.log("DEBUG", "Repeated command (" + wt([e, t]) + ") is dropped"), !0; r = 20 === e || 23 === e ? 1 : 2; var i = this.channels[r - 1]; return 20 === e || 28 === e ? 32 === t ? i.ccRCL() : 33 === t ? i.ccBS() : 34 === t ? i.ccAOF() : 35 === t ? i.ccAON() : 36 === t ? i.ccDER() : 37 === t ? i.ccRU(2) : 38 === t ? i.ccRU(3) : 39 === t ? i.ccRU(4) : 40 === t ? i.ccFON() : 41 === t ? i.ccRDC() : 42 === t ? i.ccTR() : 43 === t ? i.ccRTD() : 44 === t ? i.ccEDM() : 45 === t ? i.ccCR() : 46 === t ? i.ccENM() : 47 === t && i.ccEOC() : i.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0 }, t.parseMidrow = function (e, t) { var r = null; return (17 === e || 25 === e) && 32 <= t && t <= 47 && ((r = 17 === e ? 1 : 2) !== this.currChNr ? (Ot.log("ERROR", "Mismatch channel in midrow parsing"), !1) : (this.channels[r - 1].ccMIDROW(t), Ot.log("DEBUG", "MIDROW (" + wt([e, t]) + ")"), !0)) }, t.parsePAC = function (e, t) { var r, i = null; if (!((17 <= e && e <= 23 || 25 <= e && e <= 31) && 64 <= t && t <= 127) && !((16 === e || 24 === e) && 64 <= t && t <= 95)) return !1; if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, !(this.lastCmdB = null); r = e <= 23 ? 1 : 2, i = 64 <= t && t <= 95 ? 1 == r ? St[e] : Rt[e] : 1 == r ? _t[e] : At[e]; var a = this.interpretPAC(i, t); return this.channels[r - 1].setPAC(a), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0 }, t.interpretPAC = function (e, t) { var r = t, i = { color: null, italics: !1, indent: null, underline: !1, row: e }, r = 95 < t ? t - 96 : t - 64; return i.underline = 1 == (1 & r), r <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = "white") : i.indent = 4 * Math.floor((r - 16) / 2), i }, t.parseChars = function (e, t) { var r, i, a = null, n = null, s = null; return 17 <= (s = 25 <= e ? (a = 2, e - 8) : (a = 1, e)) && s <= 19 ? (r = t, r = 17 === s ? t + 80 : 18 === s ? t + 112 : t + 144, Ot.log("INFO", "Special char '" + yt(r) + "' in channel " + a), n = [r]) : 32 <= e && e <= 127 && (n = 0 === t ? [e] : [e, t]), n && (i = wt(n), Ot.log("DEBUG", "Char codes =  " + i.join(",")), this.lastCmdA = null, this.lastCmdB = null), n }, t.parseBackgroundAttributes = function (e, t) { var r, i, a; return ((16 === e || 24 === e) && 32 <= t && t <= 47 || (23 === e || 31 === e) && 45 <= t && t <= 47) && (r = {}, 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = kt[i], t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0)), a = e < 24 ? 1 : 2, this.channels[a - 1].setBkgData(r), this.lastCmdA = null, !(this.lastCmdB = null)) }, t.reset = function () { for (var e = 0; e < this.channels.length; e++)this.channels[e] && this.channels[e].reset(); this.lastCmdA = null, this.lastCmdB = null }, t.cueSplitAtTime = function (e) { for (var t = 0; t < this.channels.length; t++)this.channels[t] && this.channels[t].cueSplitAtTime(e) }, e }(), Nt = function () { function e(e, t) { this.timelineController = void 0, this.trackName = void 0, this.startTime = void 0, this.endTime = void 0, this.screen = void 0, this.timelineController = e, this.trackName = t, this.startTime = null, this.endTime = null, this.screen = null } var t = e.prototype; return t.dispatchCue = function () { null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen), this.startTime = null) }, t.newCue = function (e, t, r) { (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName) }, e }(), Ut = { parse: function (e, t, i, a, r, n) { var s, o = Object(Ne.utf8ArrayToStr)(new Uint8Array(e)).trim().replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), l = "00:00.000", u = 0, d = 0, c = 0, h = [], f = !0, g = !1, p = new vt; p.oncue = function (e) { var t = i[a], r = i.ccOffset; t && t.new && (void 0 !== d ? r = i.ccOffset = t.start : function (e, t, r) { var i = e[t], a = e[i.prevCC]; if (!a || !a.new && i.new) return e.ccOffset = e.presentationOffset = i.start, i.new = !1; for (; a && a.new;)e.ccOffset += i.start - a.start, i.new = !1, a = e[(i = a).prevCC]; e.presentationOffset = r }(i, a, c)), c && (r = c - i.presentationOffset), g && (e.startTime += r - d, e.endTime += r - d), e.id = Dt(e.startTime.toString()) + Dt(e.endTime.toString()) + Dt(e.text), e.text = decodeURIComponent(encodeURIComponent(e.text)), 0 < e.endTime && h.push(e) }, p.onparsingerror = function (e) { s = e }, p.onflush = function () { s && n ? n(s) : r(h) }, o.forEach(function (e) { if (f) { if (Lt(e, "X-TIMESTAMP-MAP=")) { g = !(f = !1), e.substr(16).split(",").forEach(function (e) { Lt(e, "LOCAL:") ? l = e.substr(6) : Lt(e, "MPEGTS:") && (u = parseInt(e.substr(7))) }); try { t + (9e4 * i[a].start || 0) < 0 && (t += 8589934592), u -= t, d = function (e) { var t = parseInt(e.substr(-3)), r = parseInt(e.substr(-6, 2)), i = parseInt(e.substr(-9, 2)), a = 9 < e.length ? parseInt(e.substr(0, e.indexOf(":"))) : 0; if (!(Object(F.isFiniteNumber)(t) && Object(F.isFiniteNumber)(r) && Object(F.isFiniteNumber)(i) && Object(F.isFiniteNumber)(a))) throw Error("Malformed X-TIMESTAMP-MAP: Local:" + e); return t += 1e3 * r, t += 6e4 * i, t += 36e5 * a }(l) / 1e3, c = u / 9e4 } catch (e) { g = !1, s = e } return } "" === e && (f = !1) } p.parse(e + "\n") }), p.flush() } }; function Bt(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } var Gt = function (a) { var e, t; function r(e) { var t, r, i = a.call(this, e, M.default.MEDIA_ATTACHING, M.default.MEDIA_DETACHING, M.default.FRAG_PARSING_USERDATA, M.default.FRAG_DECRYPTED, M.default.MANIFEST_LOADING, M.default.MANIFEST_LOADED, M.default.FRAG_LOADED, M.default.INIT_PTS_FOUND) || this; return i.media = null, i.config = void 0, i.enabled = !0, i.Cues = void 0, i.textTracks = [], i.tracks = [], i.initPTS = [], i.unparsedVttFrags = [], i.cueRanges = [], i.captionsTracks = {}, i.captionsProperties = void 0, i.cea608Parser = void 0, i.lastSn = -1, i.prevCC = -1, i.vttCCs = null, i.hls = e, i.config = e.config, i.Cues = e.config.cueHandler, i.captionsProperties = { textTrack1: { label: i.config.captionsTextTrack1Label, languageCode: i.config.captionsTextTrack1LanguageCode }, textTrack2: { label: i.config.captionsTextTrack2Label, languageCode: i.config.captionsTextTrack2LanguageCode } }, i.config.enableCEA708Captions && (t = new Nt(Bt(i), "textTrack1"), r = new Nt(Bt(i), "textTrack2"), i.cea608Parser = new Mt(0, t, r)), i } t = a, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var i = r.prototype; return i.addCues = function (e, t, r, i) { for (var a, n, s, o, l = this.cueRanges, u = !1, d = l.length; d--;) { var c = l[d], h = (a = c[0], n = c[1], s = t, o = r, Math.min(n, o) - Math.max(a, s)); if (0 <= h && (c[0] = Math.min(c[0], t), c[1] = Math.max(c[1], r), u = !0, .5 < h / (r - t))) return } u || l.push([t, r]), this.Cues.newCue(this.captionsTracks[e], t, r, i) }, i.onInitPtsFound = function (e) { var t = this, r = e.frag, i = e.id, a = e.initPTS, n = this.unparsedVttFrags; "main" === i && (this.initPTS[r.cc] = a), n.length && (this.unparsedVttFrags = [], n.forEach(function (e) { t.onFragLoaded(e) })) }, i.getExistingTrack = function (e) { var t = this.media; if (t) for (var r = 0; r < t.textTracks.length; r++) { var i = t.textTracks[r]; if (i[e]) return i } return null }, i.createCaptionsTrack = function (e) { var t, r, i = this.captionsProperties, a = this.captionsTracks, n = this.media, s = i[e], o = s.label, l = s.languageCode; a[e] || ((t = this.getExistingTrack(e)) ? (a[e] = t, Be(a[e]), Ue(a[e], n)) : (r = this.createTextTrack("captions", o, l)) && (r[e] = !0, a[e] = r)) }, i.createTextTrack = function (e, t, r) { var i = this.media; if (i) return i.addTextTrack(e, t, r) }, i.destroy = function () { a.prototype.destroy.call(this) }, i.onMediaAttaching = function (e) { this.media = e.media, this._cleanTracks() }, i.onMediaDetaching = function () { var t = this.captionsTracks; Object.keys(t).forEach(function (e) { Be(t[e]), delete t[e] }) }, i.onManifestLoading = function () { this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !1 } }, this._cleanTracks() }, i._cleanTracks = function () { var e = this.media; if (e) { var t = e.textTracks; if (t) for (var r = 0; r < t.length; r++)Be(t[r]) } }, i.onManifestLoaded = function (e) { var o, l = this; this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cueRanges = [], this.config.enableWebVTT && (this.tracks = e.subtitles || [], o = this.media ? this.media.textTracks : [], this.tracks.forEach(function (e, t) { var r, i, a; if (t < o.length) { for (var n = null, s = 0; s < o.length; s++)if (i = o[s], a = e, i && i.label === a.name && !i.textTrack1 && !i.textTrack2) { n = o[s]; break } n && (r = n) } r = r || l.createTextTrack("subtitles", e.name, e.lang), e.default ? r.mode = l.hls.subtitleDisplay ? "showing" : "hidden" : r.mode = "disabled", l.textTracks.push(r) })) }, i.onFragLoaded = function (e) { var t = e.frag, r = e.payload, i = this.cea608Parser, a = this.initPTS, n = this.lastSn, s = this.unparsedVttFrags; if ("main" === t.type) { var o = t.sn; t.sn !== n + 1 && i && i.reset(), this.lastSn = o } else if ("subtitle" === t.type) if (r.byteLength) { if (!Object(F.isFiniteNumber)(a[t.cc])) return s.push(e), void (a.length && this.hls.trigger(M.default.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t })); var l = t.decryptdata; null != l && null != l.key && "AES-128" === l.method || this._parseVTTs(t, r) } else this.hls.trigger(M.default.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t }) }, i._parseVTTs = function (t, e) { var r = this.hls, i = this.prevCC, a = this.textTracks, n = this.vttCCs; n[t.cc] || (n[t.cc] = { start: t.start, prevCC: i, new: !0 }, this.prevCC = t.cc), Ut.parse(e, this.initPTS[t.cc], n, t.cc, function (e) { var i = a[t.level]; "disabled" !== i.mode ? (e.forEach(function (t) { if (!i.cues.getCueById(t.id)) try { if (i.addCue(t), !i.cues.getCueById(t.id)) throw new Error("addCue is failed for: " + t) } catch (e) { N.logger.debug("Failed occurred on adding cues: " + e); var r = new window.TextTrackCue(t.startTime, t.endTime, t.text); r.id = t.id, i.addCue(r) } }), r.trigger(M.default.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: t })) : r.trigger(M.default.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t }) }, function (e) { N.logger.log("Failed to parse VTT cue: " + e), r.trigger(M.default.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t }) }) }, i.onFragDecrypted = function (e) { var t = e.frag, r = e.payload; if ("subtitle" === t.type) { if (!Object(F.isFiniteNumber)(this.initPTS[t.cc])) return void this.unparsedVttFrags.push(e); this._parseVTTs(t, r) } }, i.onFragParsingUserdata = function (e) { if (this.enabled && this.cea608Parser) for (var t = 0; t < e.samples.length; t++) { var r, i = e.samples[t].bytes; i && (r = this.extractCea608Data(i), this.cea608Parser.addData(e.samples[t].pts, r)) } }, i.extractCea608Data = function (e) { for (var t, r, i, a = 31 & e[0], n = 2, s = [], o = 0; o < a; o++)t = e[n++], r = 127 & e[n++], i = 127 & e[n++], 0 == r && 0 == i || 0 != (4 & t) && 0 == (3 & t) && (s.push(r), s.push(i)); return s }, r }(u); function jt(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function Kt(e) { for (var t = [], r = 0; r < e.length; r++) { var i = e[r]; "subtitles" === i.kind && i.label && t.push(e[r]) } return t } var Ht = function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHING, M.default.MANIFEST_LOADED, M.default.SUBTITLE_TRACK_LOADED) || this; return t.tracks = [], t.trackId = -1, t.media = null, t.stopped = !0, t.subtitleDisplay = !0, t.queuedDefaultTrack = null, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = i.prototype; return o.destroy = function () { u.prototype.destroy.call(this) }, o.onMediaAttached = function (e) { var t = this; this.media = e.media, this.media && (Object(F.isFiniteNumber)(this.queuedDefaultTrack) && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = null), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function () { t.trackChangeListener() }, 500) : this.media.textTracks.addEventListener("change", this.trackChangeListener)) }, o.onMediaDetaching = function () { this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener("change", this.trackChangeListener), Object(F.isFiniteNumber)(this.subtitleTrack) && (this.queuedDefaultTrack = this.subtitleTrack), Kt(this.media.textTracks).forEach(function (e) { Be(e) }), this.subtitleTrack = -1, this.media = null) }, o.onManifestLoaded = function (e) { var t = this, r = e.subtitles || []; this.tracks = r, this.hls.trigger(M.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: r }), r.forEach(function (e) { e.default && (t.media ? t.subtitleTrack = e.id : t.queuedDefaultTrack = e.id) }) }, o.onSubtitleTrackLoaded = function (e) { var t, r = this, i = e.id, a = e.details, n = this.trackId, s = this.tracks, o = s[n]; i >= s.length || i !== n || !o || this.stopped ? this._clearReloadTimer() : (N.logger.log("subtitle track " + i + " loaded"), a.live ? (t = se(o.details, a, e.stats.trequest), N.logger.log("Reloading live subtitle playlist in " + t + "ms"), this.timer = setTimeout(function () { r._loadCurrentTrack() }, t)) : this._clearReloadTimer()) }, o.startLoad = function () { this.stopped = !1, this._loadCurrentTrack() }, o.stopLoad = function () { this.stopped = !0, this._clearReloadTimer() }, o._clearReloadTimer = function () { this.timer && (clearTimeout(this.timer), this.timer = null) }, o._loadCurrentTrack = function () { var e = this.trackId, t = this.tracks, r = this.hls, i = t[e]; e < 0 || !i || i.details && !i.details.live || (N.logger.log("Loading subtitle track " + e), r.trigger(M.default.SUBTITLE_TRACK_LOADING, { url: i.url, id: e })) }, o._toggleTrackModes = function (e) { var t, r, i, a = this.media, n = this.subtitleDisplay, s = this.trackId; a && (t = Kt(a.textTracks), -1 === e ? [].slice.call(t).forEach(function (e) { e.mode = "disabled" }) : (r = t[s]) && (r.mode = "disabled"), (i = t[e]) && (i.mode = n ? "showing" : "hidden")) }, o._setSubtitleTrackInternal = function (e) { var t = this.hls, r = this.tracks; !Object(F.isFiniteNumber)(e) || e < -1 || e >= r.length || (this.trackId = e, N.logger.log("Switching to subtitle track " + e), t.trigger(M.default.SUBTITLE_TRACK_SWITCH, { id: e }), this._loadCurrentTrack()) }, o._onTextTracksChanged = function () { if (this.media) { for (var e = -1, t = Kt(this.media.textTracks), r = 0; r < t.length; r++)if ("hidden" === t[r].mode) e = r; else if ("showing" === t[r].mode) { e = r; break } this.subtitleTrack = e } }, a = i, (n = [{ key: "subtitleTracks", get: function () { return this.tracks } }, { key: "subtitleTrack", get: function () { return this.trackId }, set: function (e) { this.trackId !== e && (this._toggleTrackModes(e), this._setSubtitleTrackInternal(e)) } }]) && jt(a.prototype, n), s && jt(a, s), i }(u), Vt = r("./src/crypt/decrypter.js"); var Yt, Wt, qt = window.performance, zt = function (i) { var e, t; function r(e, t) { var r = i.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHING, M.default.ERROR, M.default.KEY_LOADED, M.default.FRAG_LOADED, M.default.SUBTITLE_TRACKS_UPDATED, M.default.SUBTITLE_TRACK_SWITCH, M.default.SUBTITLE_TRACK_LOADED, M.default.SUBTITLE_FRAG_PROCESSED, M.default.LEVEL_UPDATED) || this; return r.fragmentTracker = t, r.config = e.config, r.state = ve, r.tracks = [], r.tracksBuffered = [], r.currentTrackId = -1, r.decrypter = new Vt.default(e, e.config), r.lastAVStart = 0, r._onMediaSeeking = r.onMediaSeeking.bind(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(r)), r } t = i, (e = r).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a = r.prototype; return a.onSubtitleFragProcessed = function (e) { var t = e.frag, r = e.success; if (this.fragPrevious = t, this.state = ye, r) { var i = this.tracksBuffered[this.currentTrackId]; if (i) { for (var a, n = t.start, s = 0; s < i.length; s++)if (n >= i[s].start && n <= i[s].end) { a = i[s]; break } var o = t.start + t.duration; a ? a.end = o : (a = { start: n, end: o }, i.push(a)) } } }, a.onMediaAttached = function (e) { var t = e.media; (this.media = t).addEventListener("seeking", this._onMediaSeeking), this.state = ye }, a.onMediaDetaching = function () { var t = this; this.media && (this.media.removeEventListener("seeking", this._onMediaSeeking), this.fragmentTracker.removeAllFragments(), this.currentTrackId = -1, this.tracks.forEach(function (e) { t.tracksBuffered[e.id] = [] }), this.media = null, this.state = ve) }, a.onError = function (e) { var t = e.frag; t && "subtitle" === t.type && (this.state = ye) }, a.onSubtitleTracksUpdated = function (e) { var t = this; N.logger.log("subtitle tracks updated"), this.tracksBuffered = [], this.tracks = e.subtitleTracks, this.tracks.forEach(function (e) { t.tracksBuffered[e.id] = [] }) }, a.onSubtitleTrackSwitch = function (e) { var t; this.currentTrackId = e.id, this.tracks && this.tracks.length && -1 !== this.currentTrackId ? (t = this.tracks[this.currentTrackId]) && t.details && this.setInterval(500) : this.clearInterval() }, a.onSubtitleTrackLoaded = function (e) { var t = e.id, r = e.details, i = this.currentTrackId, a = this.tracks, n = a[i]; t >= a.length || t !== i || !n || (r.live && function (e, t, r) { void 0 === r && (r = 0); var i = -1; ne(e, t, function (e, t, r) { t.start = e.start, i = r }); var a = t.fragments; if (i < 0) a.forEach(function (e) { e.start += r }); else for (var n = i + 1; n < a.length; n++)a[n].start = a[n - 1].start + a[n - 1].duration }(n.details, r, this.lastAVStart), n.details = r, this.setInterval(500)) }, a.onKeyLoaded = function () { this.state === Te && (this.state = ye) }, a.onFragLoaded = function (e) { var r, t = this.fragCurrent, i = e.frag.decryptdata, a = e.frag, n = this.hls; this.state === be && t && "subtitle" === e.frag.type && t.sn === e.frag.sn && 0 < e.payload.byteLength && i && i.key && "AES-128" === i.method && (r = qt.now(), this.decrypter.decrypt(e.payload, i.key.buffer, i.iv.buffer, function (e) { var t = qt.now(); n.trigger(M.default.FRAG_DECRYPTED, { frag: a, payload: e, stats: { tstart: r, tdecrypt: t } }) })) }, a.onLevelUpdated = function (e) { var t = e.details.fragments; this.lastAVStart = t.length ? t[0].start : 0 }, a.doTick = function () { if (this.media) switch (this.state) { case ye: var e = this.config, t = this.currentTrackId, r = this.fragmentTracker, i = this.media, a = this.tracks; if (!a || !a[t] || !a[t].details) break; var n = e.maxBufferHole, s = e.maxFragLookUpTolerance, o = Math.min(e.maxBufferLength, e.maxMaxBufferLength), l = Y.bufferedInfo(this._getBuffered(), i.currentTime, n), u = l.end, d = l.len, c = a[t].details, h = c.fragments, f = h.length, g = h[f - 1].start + h[f - 1].duration; if (o < d) return; var p, v = this.fragPrevious; (p = u < g ? (v && c.hasProgramDateTime && (p = ce(h, v.endProgramDateTime, s)), p || he(v, h, u, s)) : h[f - 1]) && p.encrypted ? (N.logger.log("Loading key for " + p.sn), this.state = Te, this.hls.trigger(M.default.KEY_LOADING, { frag: p })) : p && r.getState(p) === B && (this.fragCurrent = p, this.state = be, this.hls.trigger(M.default.FRAG_LOADING, { frag: p })) } else this.state = ye }, a.stopLoad = function () { this.lastAVStart = 0, i.prototype.stopLoad.call(this) }, a._getBuffered = function () { return this.tracksBuffered[this.currentTrackId] || [] }, a.onMediaSeeking = function () { this.fragPrevious = null }, r }(Ce); (Wt = Yt = Yt || {}).WIDEVINE = "com.widevine.alpha", Wt.PLAYREADY = "com.microsoft.playready"; var Xt = "undefined" != typeof window && window.navigator && window.navigator.requestMediaKeySystemAccess ? window.navigator.requestMediaKeySystemAccess.bind(window.navigator) : null; function Qt(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function $t(e, t, r) { switch (e) { case Yt.WIDEVINE: return i = { videoCapabilities: [] }, r.forEach(function (e) { i.videoCapabilities.push({ contentType: 'video/mp4; codecs="' + e + '"' }) }), [i]; default: throw new Error("Unknown key-system: " + e) }var i } var Jt = function (a) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}, t = Object.keys(n); "function" == typeof Object.getOwnPropertySymbols && (t = t.concat(Object.getOwnPropertySymbols(n).filter(function (e) { return Object.getOwnPropertyDescriptor(n, e).enumerable }))), t.forEach(function (e) { var t, r, i; t = a, i = n[r = e], r in t ? Object.defineProperty(t, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[r] = i }) } return a }({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, initialLiveManifestSize: 1, maxBufferLength: 30, maxBufferSize: 6e7, maxBufferHole: .5, lowBufferWatchdogPeriod: .5, highBufferWatchdogPeriod: 3, nudgeOffset: .1, nudgeMaxRetry: 3, maxFragLookUpTolerance: .25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, liveDurationInfinity: !1, liveBackBufferLength: 1 / 0, maxMaxBufferLength: 600, enableWorker: !0, enableSoftwareAES: !0, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, startLevel: void 0, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: .2, appendErrorMaxRetry: 3, loader: tt, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, abrController: Ye, bufferController: qe, capLevelController: Xe, fpsController: $e, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrBandWidthFactor: .95, abrBandWidthUpFactor: .7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, requestMediaKeySystemAccessFunc: Xt }, function () { 0; return { cueHandler: i, enableCEA708Captions: !0, enableWebVTT: !0, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es" } }(), { subtitleStreamController: zt, subtitleTrackController: Ht, timelineController: Gt, audioStreamController: ot, audioTrackController: it, emeController: function (r) { var e, t; function i(e) { var t = r.call(this, e, M.default.MEDIA_ATTACHED, M.default.MEDIA_DETACHED, M.default.MANIFEST_PARSED) || this; return t._widevineLicenseUrl = void 0, t._licenseXhrSetup = void 0, t._emeEnabled = void 0, t._requestMediaKeySystemAccess = void 0, t._config = void 0, t._mediaKeysList = [], t._media = null, t._hasSetMediaKeys = !1, t._requestLicenseFailureCount = 0, t._onMediaEncrypted = function (e) { N.logger.log('Media is encrypted using "' + e.initDataType + '" init data type'), t._attemptSetMediaKeys(), t._generateRequestWithPreferredKeySession(e.initDataType, e.initData) }, t._config = e.config, t._widevineLicenseUrl = t._config.widevineLicenseUrl, t._licenseXhrSetup = t._config.licenseXhrSetup, t._emeEnabled = t._config.emeEnabled, t._requestMediaKeySystemAccess = t._config.requestMediaKeySystemAccessFunc, t } t = r, (e = i).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t; var a, n, s, o = i.prototype; return o.getLicenseServerUrl = function (e) { switch (e) { case Yt.WIDEVINE: if (!this._widevineLicenseUrl) break; return this._widevineLicenseUrl }throw new Error('no license server URL configured for key-system "' + e + '"') }, o._attemptKeySystemAccess = function (t, e, r) { var i = this, a = $t(t, 0, r); N.logger.log("Requesting encrypted media key-system access"), this.requestMediaKeySystemAccess(t, a).then(function (e) { i._onMediaKeySystemAccessObtained(t, e) }).catch(function (e) { N.logger.error('Failed to obtain key-system "' + t + '" access:', e) }) }, o._onMediaKeySystemAccessObtained = function (t, e) { var r = this; N.logger.log('Access for key-system "' + t + '" obtained'); var i = { mediaKeysSessionInitialized: !1, mediaKeySystemAccess: e, mediaKeySystemDomain: t }; this._mediaKeysList.push(i), e.createMediaKeys().then(function (e) { i.mediaKeys = e, N.logger.log('Media-keys created for key-system "' + t + '"'), r._onMediaKeysCreated() }).catch(function (e) { N.logger.error("Failed to create media-keys:", e) }) }, o._onMediaKeysCreated = function () { var t = this; this._mediaKeysList.forEach(function (e) { e.mediaKeysSession || (e.mediaKeysSession = e.mediaKeys.createSession(), t._onNewMediaKeySession(e.mediaKeysSession)) }) }, o._onNewMediaKeySession = function (t) { var r = this; N.logger.log("New key-system session " + t.sessionId), t.addEventListener("message", function (e) { r._onKeySessionMessage(t, e.message) }, !1) }, o._onKeySessionMessage = function (t, e) { N.logger.log("Got EME message event, creating license request"), this._requestLicense(e, function (e) { N.logger.log("Received license data (length: " + (e ? e.byteLength : e) + "), updating key-session"), t.update(e) }) }, o._attemptSetMediaKeys = function () { if (!this._media) throw new Error("Attempted to set mediaKeys without first attaching a media element"); if (!this._hasSetMediaKeys) { var e = this._mediaKeysList[0]; if (!e || !e.mediaKeys) return N.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"), void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_KEYS, fatal: !0 }); N.logger.log("Setting keys for encrypted media"), this._media.setMediaKeys(e.mediaKeys), this._hasSetMediaKeys = !0 } }, o._generateRequestWithPreferredKeySession = function (e, t) { var r = this, i = this._mediaKeysList[0]; if (!i) return N.logger.error("Fatal: Media is encrypted but not any key-system access has been obtained yet"), void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_ACCESS, fatal: !0 }); if (i.mediaKeysSessionInitialized) N.logger.warn("Key-Session already initialized but requested again"); else { var a = i.mediaKeysSession; if (!a) return N.logger.error("Fatal: Media is encrypted but no key-session existing"), void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_SESSION, fatal: !0 }); if (!t) return N.logger.warn("Fatal: initData required for generating a key session is null"), void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_INIT_DATA, fatal: !0 }); N.logger.log('Generating key-session request for "' + e + '" init data type'), i.mediaKeysSessionInitialized = !0, a.generateRequest(e, t).then(function () { N.logger.debug("Key-session generation succeeded") }).catch(function (e) { N.logger.error("Error generating key-session request:", e), r.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_SESSION, fatal: !1 }) }) } }, o._createLicenseXhr = function (t, e, r) { var i = new XMLHttpRequest, a = this._licenseXhrSetup; try { if (a) try { a(i, t) } catch (e) { i.open("POST", t, !0), a(i, t) } i.readyState || i.open("POST", t, !0) } catch (e) { throw new Error("issue setting up KeySystem license XHR " + e) } return i.responseType = "arraybuffer", i.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, i, t, e, r), i }, o._onLicenseRequestReadyStageChange = function (e, t, r, i) { switch (e.readyState) { case 4: if (200 === e.status) this._requestLicenseFailureCount = 0, N.logger.log("License request succeeded"), "arraybuffer" !== e.responseType && N.logger.warn("xhr response type was not set to the expected arraybuffer for license request"), i(e.response); else { if (N.logger.error("License Request XHR failed (" + t + "). Status: " + e.status + " (" + e.statusText + ")"), this._requestLicenseFailureCount++, 3 < this._requestLicenseFailureCount) return void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0 }); var a = 3 - this._requestLicenseFailureCount + 1; N.logger.warn("Retrying license request, " + a + " attempts left"), this._requestLicense(r, i) } } }, o._generateLicenseRequestChallenge = function (e, t) { switch (e.mediaKeySystemDomain) { case Yt.WIDEVINE: return t }throw new Error("unsupported key-system: " + e.mediaKeySystemDomain) }, o._requestLicense = function (e, t) { N.logger.log("Requesting content license for key-system"); var r = this._mediaKeysList[0]; if (!r) return N.logger.error("Fatal error: Media is encrypted but no key-system access has been obtained yet"), void this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_NO_ACCESS, fatal: !0 }); try { var i = this.getLicenseServerUrl(r.mediaKeySystemDomain), a = this._createLicenseXhr(i, e, t); N.logger.log("Sending license request to URL: " + i); var n = this._generateLicenseRequestChallenge(r, e); a.send(n) } catch (e) { N.logger.error("Failure requesting DRM license: " + e), this.hls.trigger(M.default.ERROR, { type: h.ErrorTypes.KEY_SYSTEM_ERROR, details: h.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0 }) } }, o.onMediaAttached = function (e) { var t; this._emeEnabled && (t = e.media, (this._media = t).addEventListener("encrypted", this._onMediaEncrypted)) }, o.onMediaDetached = function () { this._media && (this._media.removeEventListener("encrypted", this._onMediaEncrypted), this._media = null) }, o.onManifestParsed = function (e) { var t, r; this._emeEnabled && (t = e.levels.map(function (e) { return e.audioCodec }), r = e.levels.map(function (e) { return e.videoCodec }), this._attemptKeySystemAccess(Yt.WIDEVINE, t, r)) }, a = i, (n = [{ key: "requestMediaKeySystemAccess", get: function () { if (!this._requestMediaKeySystemAccess) throw new Error("No requestMediaKeySystemAccess function configured"); return this._requestMediaKeySystemAccess } }]) && Qt(a.prototype, n), s && Qt(a, s), i }(u) }); function Zt(a) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}, t = Object.keys(n); "function" == typeof Object.getOwnPropertySymbols && (t = t.concat(Object.getOwnPropertySymbols(n).filter(function (e) { return Object.getOwnPropertyDescriptor(n, e).enumerable }))), t.forEach(function (e) { var t, r, i; t = a, i = n[r = e], r in t ? Object.defineProperty(t, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[r] = i }) } return a } function er(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function tr(e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function rr(e, t, r) { return t && tr(e.prototype, t), r && tr(e, r), e } r.d(t, "default", function () { return ir }); var ir = function (T) { var e, t; function b(e) { var t; void 0 === e && (e = {}), (t = T.call(this) || this).config = void 0, t._autoLevelCapping = void 0, t.abrController = void 0, t.capLevelController = void 0, t.levelController = void 0, t.streamController = void 0, t.networkControllers = void 0, t.audioTrackController = void 0, t.subtitleTrackController = void 0, t.emeController = void 0, t.coreComponents = void 0, t.media = null, t.url = null; var r = b.DefaultConfig; if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); t.config = Zt({}, r, e); var i = er(t).config; if (void 0 !== i.liveMaxLatencyDurationCount && i.liveMaxLatencyDurationCount <= i.liveSyncDurationCount) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"'); if (void 0 !== i.liveMaxLatencyDuration && (void 0 === i.liveSyncDuration || i.liveMaxLatencyDuration <= i.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"'); Object(N.enableLogs)(i.debug), t._autoLevelCapping = -1; var a = t.abrController = new i.abrController(er(t)), n = new i.bufferController(er(t)), s = t.capLevelController = new i.capLevelController(er(t)), o = new i.fpsController(er(t)), l = new k(er(t)), u = new P(er(t)), d = new U(er(t)), c = new Ge(er(t)), h = t.levelController = new Me(er(t)), f = new H(er(t)), g = [h, t.streamController = new xe(er(t), f)], p = i.audioStreamController; p && g.push(new p(er(t), f)), t.networkControllers = g; var v, m, y, E = [l, u, d, a, n, s, o, c, f]; return (p = i.audioTrackController) && (v = new p(er(t)), t.audioTrackController = v, E.push(v)), (p = i.subtitleTrackController) && (m = new p(er(t)), t.subtitleTrackController = m, g.push(m)), (p = i.emeController) && (y = new p(er(t)), t.emeController = y, E.push(y)), (p = i.subtitleStreamController) && g.push(new p(er(t), f)), (p = i.timelineController) && E.push(new p(er(t))), t.coreComponents = E, t } t = T, (e = b).prototype = Object.create(t.prototype), (e.prototype.constructor = e).__proto__ = t, b.isSupported = function () { var e = X(); if (!e) return !1; var t = self.SourceBuffer || self.WebKitSourceBuffer, r = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), i = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove; return !!r && !!i }, rr(b, null, [{ key: "version", get: function () { return "0.13.2" } }, { key: "Events", get: function () { return M.default } }, { key: "ErrorTypes", get: function () { return h.ErrorTypes } }, { key: "ErrorDetails", get: function () { return h.ErrorDetails } }, { key: "DefaultConfig", get: function () { return b.defaultConfig ? b.defaultConfig : Jt }, set: function (e) { b.defaultConfig = e } }]); var r = b.prototype; return r.destroy = function () { N.logger.log("destroy"), this.trigger(M.default.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function (e) { e.destroy() }), this.url = null, this.removeAllListeners(), this._autoLevelCapping = -1 }, r.attachMedia = function (e) { N.logger.log("attachMedia"), this.media = e, this.trigger(M.default.MEDIA_ATTACHING, { media: e }) }, r.detachMedia = function () { N.logger.log("detachMedia"), this.trigger(M.default.MEDIA_DETACHING), this.media = null }, r.loadSource = function (e) { e = s.buildAbsoluteURL(window.location.href, e, { alwaysNormalize: !0 }), N.logger.log("loadSource:" + e), this.url = e, this.trigger(M.default.MANIFEST_LOADING, { url: e }) }, r.startLoad = function (t) { void 0 === t && (t = -1), N.logger.log("startLoad(" + t + ")"), this.networkControllers.forEach(function (e) { e.startLoad(t) }) }, r.stopLoad = function () { N.logger.log("stopLoad"), this.networkControllers.forEach(function (e) { e.stopLoad() }) }, r.swapAudioCodec = function () { N.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec() }, r.recoverMediaError = function () { N.logger.log("recoverMediaError"); var e = this.media; this.detachMedia(), e && this.attachMedia(e) }, rr(b, [{ key: "levels", get: function () { return this.levelController.levels } }, { key: "currentLevel", get: function () { return this.streamController.currentLevel }, set: function (e) { N.logger.log("set currentLevel:" + e), this.loadLevel = e, this.streamController.immediateLevelSwitch() } }, { key: "nextLevel", get: function () { return this.streamController.nextLevel }, set: function (e) { N.logger.log("set nextLevel:" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } }, { key: "loadLevel", get: function () { return this.levelController.level }, set: function (e) { N.logger.log("set loadLevel:" + e), this.levelController.manualLevel = e } }, { key: "nextLoadLevel", get: function () { return this.levelController.nextLoadLevel }, set: function (e) { this.levelController.nextLoadLevel = e } }, { key: "firstLevel", get: function () { return Math.max(this.levelController.firstLevel, this.minAutoLevel) }, set: function (e) { N.logger.log("set firstLevel:" + e), this.levelController.firstLevel = e } }, { key: "startLevel", get: function () { return this.levelController.startLevel }, set: function (e) { N.logger.log("set startLevel:" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } }, { key: "capLevelToPlayerSize", set: function (e) { var t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t) } }, { key: "autoLevelCapping", get: function () { return this._autoLevelCapping }, set: function (e) { N.logger.log("set autoLevelCapping:" + e), this._autoLevelCapping = e } }, { key: "bandwidthEstimate", get: function () { var e = this.abrController._bwEstimator; return e ? e.getEstimate() : NaN } }, { key: "autoLevelEnabled", get: function () { return -1 === this.levelController.manualLevel } }, { key: "manualLevel", get: function () { return this.levelController.manualLevel } }, { key: "minAutoLevel", get: function () { for (var e = this.levels, t = this.config.minAutoBitrate, r = e ? e.length : 0, i = 0; i < r; i++) { if (t < (e[i].realBitrate ? Math.max(e[i].realBitrate, e[i].bitrate) : e[i].bitrate)) return i } return 0 } }, { key: "maxAutoLevel", get: function () { var e = this.levels, t = this.autoLevelCapping, r = -1 === t && e && e.length ? e.length - 1 : t; return r } }, { key: "nextAutoLevel", get: function () { return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel) }, set: function (e) { this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e) } }, { key: "audioTracks", get: function () { var e = this.audioTrackController; return e ? e.audioTracks : [] } }, { key: "audioTrack", get: function () { var e = this.audioTrackController; return e ? e.audioTrack : -1 }, set: function (e) { var t = this.audioTrackController; t && (t.audioTrack = e) } }, { key: "liveSyncPosition", get: function () { return this.streamController.liveSyncPosition } }, { key: "subtitleTracks", get: function () { var e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } }, { key: "subtitleTrack", get: function () { var e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 }, set: function (e) { var t = this.subtitleTrackController; t && (t.subtitleTrack = e) } }, { key: "subtitleDisplay", get: function () { var e = this.subtitleTrackController; return !!e && e.subtitleDisplay }, set: function (e) { var t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } }]), b }($); ir.defaultConfig = void 0 }, "./src/polyfills/number-isFinite.js": function (e, t, r) { "use strict"; r.r(t), r.d(t, "isFiniteNumber", function () { return i }); var i = Number.isFinite || function (e) { return "number" == typeof e && isFinite(e) } }, "./src/utils/get-self-scope.js": function (e, t, r) { "use strict"; function i() { return "undefined" == typeof window ? self : window } r.r(t), r.d(t, "getSelfScope", function () { return i }) }, "./src/utils/logger.js": function (e, t, r) { "use strict"; r.r(t), r.d(t, "enableLogs", function () { return u }), r.d(t, "logger", function () { return d }); var i = r("./src/utils/get-self-scope.js"); function a() { } var n = { trace: a, debug: a, log: a, warn: a, info: a, error: a }, s = n; var o = Object(i.getSelfScope)(); function l(n) { var s = o.console[n]; return s ? function () { for (var e, t, r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; i[0] && (i[0] = (e = n, t = i[0], t = "[" + e + "] > " + t)), s.apply(o.console, i) } : a } var u = function (e) { if (o.console && !0 === e || "object" == typeof e) { !function (t) { for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++)r[i - 1] = arguments[i]; r.forEach(function (e) { s[e] = t[e] ? t[e].bind(t) : l(e) }) }(e, "debug", "log", "info", "warn", "error"); try { s.log() } catch (e) { s = n } } else s = n }, d = s } }, a.c = i, a.d = function (e, t, r) { a.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }, a.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, a.t = function (t, e) { if (1 & e && (t = a(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var r = Object.create(null); if (a.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var i in t) a.d(r, i, function (e) { return t[e] }.bind(null, i)); return r }, a.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return a.d(t, "a", t), t }, a.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, a.p = "/dist/", a(a.s = "./src/hls.ts").default; function a(e) { if (i[e]) return i[e].exports; var t = i[e] = { i: e, l: !1, exports: {} }; return r[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports } var r, i }, e.exports = i()) }]);